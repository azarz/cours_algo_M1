{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil & D\u00e9roulement des s\u00e9ances","text":""},{"location":"#informatique-de-base-m1","title":"Informatique de Base - M1","text":"<p>Cours d'introduction \u00e0 l'algorithmie pour le Master 1 G\u00e9omatique de l'ENSG</p> <p>Objectifs : + D\u00e9couvrir les bases de l\u2019informatique et comprendre les concepts de l\u2019algorithmique + Comprendre la logique d\u2019un langage de programmation + R\u00e9aliser des premiers programmes avec Python</p> <p>Dur\u00e9e : 16 demi journ\u00e9es. \u00c9valuation : TP not\u00e9 (16 octobre 2019) et interrogation \u00e9crite (7 novembre 2019)</p>"},{"location":"#programme-par-demi-journees","title":"Programme par demi-journ\u00e9es","text":""},{"location":"#1-matin-du-1er-octobre-2019","title":"1 (matin du 1er octobre 2019)","text":"<p>Architecture informatique</p> <p>Validit\u00e9 des calculs dans un ordinateur</p>"},{"location":"#2-apres-midi-du-1er-octobre-2019","title":"2 (apr\u00e8s-midi du 1er octobre 2019)","text":"<p>Th\u00e9orie de l'algorithmie</p> <p>Mise en pratique de la th\u00e9orie de l'algorithmie.</p>"},{"location":"#3-matin-du-2-octobre-2019","title":"3 (matin du 2 octobre 2019)","text":"<p>Mise en pratique de la th\u00e9orie de l'algorithmie.</p>"},{"location":"#4-apres-midi-du-2-octobre-2019","title":"4 (apr\u00e8s-midi du 2 octobre 2019)","text":"<p>Approche diviser pour r\u00e9gner.</p>"},{"location":"#5-6-4-octobre-2019","title":"5 &amp; 6 (4 octobre 2019)","text":"<p>Introduction \u00e0 Python.</p> <p>Mise en pratique</p> <p>Mise en pratique 2</p>"},{"location":"#7-matin-du-7-octobre-2019","title":"7 (matin du 7 octobre 2019)","text":"<p>Introduction \u00e0 la complexit\u00e9</p> <p>Mise en pratique des notions de complexit\u00e9 (Algorithmes de tri)</p>"},{"location":"#8-apres-midi-du-7-octobre-2019","title":"8 (apr\u00e8s-midi du 7 octobre 2019)","text":"<p>Introduction \u00e0 la th\u00e9orie des graphes.</p> <p>Mise en pratique de la th\u00e9orie des graphes.</p>"},{"location":"#9-matin-du-8-octobre-2019","title":"9 (matin du 8 octobre 2019)","text":"<p>Mise en pratique de la th\u00e9orie des graphes. (Correction)</p>"},{"location":"#10-matin-du-9-octobre-2019","title":"10 (matin du 9 octobre 2019)","text":"<p>TP Python - Distance entre points</p>"},{"location":"#11-apres-midi-du-9-octobre-2019","title":"11 (apr\u00e8s-midi du 9 octobre 2019)","text":"<p>TP Python - Distance entre points (Correction)</p> <p>TP Python - G\u00e9n\u00e9ralisation cartographique</p>"},{"location":"#12-matin-du-11-octobre-2019","title":"12 (matin du 11 octobre 2019)","text":"<p>TP Python - G\u00e9n\u00e9ralisation cartographique (Correction)</p> <p>Utilisation plus avanc\u00e9e de Python</p>"},{"location":"#13-14-15-octobre-2019","title":"13 &amp; 14 (15 octobre 2019)","text":"<p>TP Python - Gestion d'association</p>"},{"location":"#15-16-16-octobre-2019","title":"15 &amp; 16 (16 octobre 2019)","text":"<p>TP not\u00e9.</p>"},{"location":"#interrogation-ecrite-le-7-novembre-2019","title":"Interrogation \u00e9crite le 7 novembre 2019","text":""},{"location":"1_Architecture_logicielle/","title":"1 - Architecture logicielle","text":""},{"location":"1_Architecture_logicielle/#objectifs","title":"Objectifs","text":"<ul> <li>Avoir des notions de bases sur la conception d'un programme informatique</li> </ul>"},{"location":"1_Architecture_logicielle/#pre-requis","title":"Pr\u00e9-requis","text":"<p>Aucun</p>"},{"location":"1_Architecture_logicielle/#architecture-logicielle","title":"Architecture logicielle","text":"<p>Les grandes phases de la conception d'un programme sont : l'analyse, l'algorithmie et la programmation.</p> <p></p>"},{"location":"1_Architecture_logicielle/#phase-danalyse","title":"Phase d'analyse","text":"<p>Avant de s'attaquer \u00e0 la r\u00e9solution d'un probl\u00e8me informatique, il est important de le formuler de fa\u00e7on pr\u00e9cise dans la \"langue de tous les jours\". L'algorithme n'est alors finalement rien d'autre que la formulation dans un langage plus concis d'un probl\u00e8me clairement \u00e9nonc\u00e9. Cette phase d'analyse doit \u00eatre d'autant plus approfondie que le probl\u00e8me est complexe. Nous n'analyserons pas de la m\u00eame fa\u00e7on la mise en place d'une cha\u00eene de production automatis\u00e9e dans une grande entreprise et le tri d'un tableau \u00e0 10 \u00e9l\u00e9ments.</p> <p>Les personnes charg\u00e9es d'analyser un probl\u00e8me important ont \u00e0 leur disposition divers m\u00e9thodes et outils (HBDS, SADT, UML, etc.) pour mener \u00e0 bien leur projet.</p>"},{"location":"1_Architecture_logicielle/#lalgorithmique","title":"L'algorithmique","text":"<p>Un algorithme est l'expression de l'ensemble des op\u00e9rations \u00e0 effectuer sur des ensembles de donn\u00e9es pour aboutir \u00e0 des ensembles de r\u00e9sultats.</p> <p>L'algorithmique est la phase d'\u00e9laboration et d'\u00e9criture de l'ensemble des algorithmes n\u00e9cessaire \u00e0 la conception d'un programme ou d'un logiciel.</p> <p>Passer par un langage algorithmique permet se concentrer sur les \u00e9tapes de r\u00e9solution d'un probl\u00e8me sans avoir \u00e0 se soucier de la machine sur laquelle le programme devra fonctionner ou des sp\u00e9cificit\u00e9s du langage de programmation qui sera utilis\u00e9. Le travail de passage d'un langage d'algorithmie \u00e0 n'importe quel langage de programmation n'est plus alors qu'une \"simple\" traduction appel\u00e9e impl\u00e9mentation ou codage.</p>"},{"location":"1_Architecture_logicielle/#la-programmation","title":"La programmation","text":"<p>La conception de logiciels pour des ordinateurs s'oppose \u00e0 un premier probl\u00e8me :</p> <ul> <li>l'humain utilise un langage qui lui est propre;</li> <li>l'ordinateur parle en binaire (suite de 0 et de 1).</li> </ul> <p>Pour pouvoir communiquer, il est d\u00e8s lors n\u00e9cessaire d'utiliser un langage :</p> <ul> <li>compr\u00e9hensible par l'homme;</li> <li>traduisible en binaire par la machine.</li> </ul> <p>C'est le langage de programmation. Un programme informatique est une succession d'instructions ex\u00e9cutables par l'ordinateur. La fa\u00e7on d'\u00e9crire un programme est tr\u00e8s li\u00e9e au langage de programmation que l'on a choisi. D'une mani\u00e8re g\u00e9n\u00e9rale, le programme est un simple fichier texte (\u00e9crit avec un traitement de texte ou un \u00e9diteur plus performant appel\u00e9 IDE), que l'on appelle fichier source. Le fichier source contient lui-m\u00eame des lignes de programmes que l'on appelle code source. Ce fichier, une fois termin\u00e9, doit \u00eatre compil\u00e9 ou interpr\u00e9t\u00e9 pour \u00eatre ex\u00e9cut\u00e9 par la machine.</p>"},{"location":"1_Architecture_logicielle/#langages-interpretes","title":"Langages interpr\u00e9t\u00e9s","text":"<p>L'interpr\u00e9tation consiste \u00e0 parcourir un programme \u00e9crit dans un langage de programmation et \u00e0 ex\u00e9cuter imm\u00e9diatement les instructions \u00e9quivalentes dans le langage machine. Le programme en langage machine n'est jamais vraiment \u00e9crit. Un programme \u00e9crit dans un langage interpr\u00e9t\u00e9 a besoin d'un programme auxiliaire (l'interpr\u00e9teur) pour traduire au fur et \u00e0 mesure les instructions du programme.</p> <p>Les langages interpr\u00e9t\u00e9s ont g\u00e9n\u00e9ralement l'avantage d'\u00eatre plus portables (moins d\u00e9pendants de l'environnement de la machine qui l'ex\u00e9cute).</p> <p>Exemples de langages interpr\u00e9t\u00e9s : BASIC, JavaScript, Ruby, PHP, PERL, etc.</p>"},{"location":"1_Architecture_logicielle/#langages-compiles","title":"Langages compil\u00e9s","text":"<p>La compilation est une op\u00e9ration consistant \u00e0 traduire le code source \u00e9crit dans un langage de programmation en langage machine. Cette traduction est effectu\u00e9e par un programme annexe appel\u00e9 compilateur qui g\u00e9n\u00e8re donc un nouveau fichier autonome, c'est-\u00e0-dire qui n'aura plus besoin d'un programme autre que lui pour s'ex\u00e9cuter; on dit d'ailleurs que ce fichier est ex\u00e9cutable.</p> <p>Un programme \u00e9crit dans un langage compil\u00e9 a comme avantage de ne plus avoir besoin, une fois compil\u00e9, de programme annexe pour s'ex\u00e9cuter. De plus, la traduction \u00e9tant faite une fois pour toute, il est plus rapide \u00e0 l'ex\u00e9cution. De plus, un programme compil\u00e9 garantit une meilleure s\u00e9curit\u00e9 du code source (le code binaire est difficilement d\u00e9chiffrable).</p> <p>Exemple de langages compil\u00e9s: C, C++, Fortran, Pascal, Go, etc.</p> <p>Remarque : la compilation se d\u00e9compose en 2 \u00e9tapes :</p> <ul> <li>le compilateur transforme le code source en code binaire (modification du   code source, traduction en assembleur puis assemblage en binaire);</li> <li>l'\u00e9dition de liens qui permet d'int\u00e9grer dans le fichier final tous les   \u00e9l\u00e9ments annexes (fonctions, librairies, fonctionnalit\u00e9s utilis\u00e9es par le   programme mais disponibles dans d'autres fichiers, etc.) auxquels le   programme fait r\u00e9f\u00e9rence mais qui ne sont pas stock\u00e9s dans le fichier source).</li> </ul>"},{"location":"1_Architecture_logicielle/#langages-intermediaires","title":"Langages interm\u00e9diaires","text":"<p>D'autres langages appartiennent aux deux cat\u00e9gories \u00e0 la fois. Dans ces cas l\u00e0, le programme est d'abord pr\u00e9-compil\u00e9 dans un langage interm\u00e9diaire appel\u00e9 g\u00e9n\u00e9ralement bytecode, qui est une sorte de langage machine de type assembleur qui n'est pas directement ex\u00e9cutable. Ce code n\u00e9cessite ensuite d'\u00eatre interpr\u00e9t\u00e9. Par exemple, le Java fait appel \u00e0 une machine virtuelle (la JVM) pour interpr\u00e9ter le bytecode pr\u00e9alablement g\u00e9n\u00e9r\u00e9.</p> <p>Les programmes \u00e9crit en langage interm\u00e9diaire gagnent en portabilit\u00e9 (le code interm\u00e9diaire est le m\u00eame pour toutes les machines) par rapport aux langages compil\u00e9, mais y perdent g\u00e9n\u00e9ralement en performance.</p> <p>Exemple de langages interm\u00e9diaires : Python, Java, etc.</p>"},{"location":"1_Architecture_logicielle/#petit-historique-des-langages","title":"Petit historique des langages","text":"<p>Le premier langage de programmation universel de haut niveau est le Fortran (Formula Transistor), invent\u00e9 en 1954. Il donnera ensuite naissance \u00e0 l'ALGOL60 et au COBOL. Aujourd'hui, de nombreux langages de programmation, souvent construit \u00e0 partir de ces premiers langages, ont vu le jour (Java, C++, Python, JavaScript, etc.).</p> <p></p>"},{"location":"1_Architecture_logicielle/#ingenierie-des-systeme-dinformation","title":"Ing\u00e9nierie des syst\u00e8me d'information","text":"<p>L'ing\u00e9nierie des syst\u00e8mes d'information vise \u00e0 transformer les besoins des utilisateurs en sp\u00e9cifications d'une application formalis\u00e9es pour le d\u00e9veloppeur. Elle regroupe un ensemble de m\u00e9thodes, techniques et outils aidant \u00e0 la formalisation de sp\u00e9cifications. Le terme de brainware a \u00e9t\u00e9 introduit en 1974 par Tosio Kitagawa mais reste assez confidentiel. L'ing\u00e9nierie des syst\u00e8me se d\u00e9veloppera vraiment \u00e0 partir des ann\u00e9es 1990 lorsque les syst\u00e8mes informatiques \u00e0 d\u00e9velopper sont devenus plus compl\u00e8xes.</p> <p>Elle s'est rapidement constitu\u00e9 un ensemble de m\u00e9thode techniques et outils visant \u00e0 assurer la qualit\u00e9 des applications. Les activit\u00e9s de l'ing\u00e9nierie des syst\u00e8mes couvrent ainsi des domaines vari\u00e9s de la r\u00e9alisation de programmes informatiques : conception, tests, documentation, m\u00e9thode de d\u00e9veloppement, etc. Les m\u00e9thodes de gestion de projet articuleront ces diff\u00e9rents \u00e9l\u00e9ments entre eux.</p> <p>Nous reviendrons dans d'autres cours sur le langage UML qui est utilis\u00e9 pour mod\u00e9liser des syst\u00e8mes informatiques dans toutes leurs dimensions. Cr\u00e9\u00e9 en 1995 par fusion d'outils existant, ce langage est aujourd'hui un standard de la conception en informatique. La m\u00e9thode Merise de conception et d\u00e9veloppement de syst\u00e8me informatiques est \u00e9galement tr\u00e8s utilis\u00e9 dans le monde professionnel.</p>"},{"location":"2_Validite_logiciel_numerique/","title":"2 - Validit\u00e9 Logiciel Num\u00e9rique","text":""},{"location":"2_Validite_logiciel_numerique/#objectifs","title":"Objectifs","text":"<ul> <li>Etre sensibilis\u00e9 aux probl\u00e8mes de pr\u00e9cision, de capacit\u00e9 et de puissance de calculs des ordinateurs.</li> </ul>"},{"location":"2_Validite_logiciel_numerique/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li>Concepts \u00e9l\u00e9mentaires en algorithmie</li> <li>Notions de base en architecture informatique</li> </ul>"},{"location":"2_Validite_logiciel_numerique/#introduction","title":"Introduction","text":"<p>L'algorithmie ou l'analyse informatique s'attachent \u00e0 d\u00e9crire des solutions informatiques th\u00e9oriques \u00e0 un probl\u00e8me pos\u00e9. Ces solutions d\u00e9crivent un cheminement pour aboutir au r\u00e9sultat excompt\u00e9 et ne souffrent d'aucune ambiguit\u00e9 : en toutes circonstances l'algorithme fournit un r\u00e9sultat.</p> <p>La mise en oeuvre pratique de ces solutions n'est pas aussi \u00e9vidente et se trouve confront\u00e9 \u00e0 plusieurs limitations : une solution th\u00e9orique apportant une r\u00e9ponse \u00e0 un probl\u00e8me peut apporter un r\u00e9sultat impr\u00e9cis une fois transpos\u00e9e sur un ordinateur ou r\u00e9soudre le probl\u00e8me mais dans des \u00e9chelles de temps non acceptables. C'est ce que nous nous proposons d'\u00e9tudier dans ce cours.</p> <p>Typiquement, l'impl\u00e9mentation d'une solution sur un ordinateur peut \u00eatre confront\u00e9e \u00e0 trois types de probl\u00e8mes :</p> <ul> <li>des probl\u00e8mes de pr\u00e9cision : 0,1+0,1+0,1-0,3 n'est pas strictement \u00e9gal \u00e0 0 en arithm\u00e9tique d'un ordinateur;</li> <li>des probl\u00e8mes de capacit\u00e9 : charger dans la m\u00e9moire vive d'un ordinateur une matrice carr\u00e9 de 100000 lignes, avec des entiers stock\u00e9s sur 8 bits, demande environ 10 Go de RAM;</li> <li>des probl\u00e8mes de puissance : pour un ordinateur grand march\u00e9 effectuant 10<sup>6</sup> op\u00e9rations par secondes, un tri naif d'un tableau de 1000000 d'\u00e9l\u00e9ments prend plus d'une semaine.</li> </ul> <p>Si les probl\u00e8mes de capacit\u00e9 sont pratiquement r\u00e9solus avec les \u00e9volutions r\u00e9centes des ordinateurs, hormis pour quelques applications tr\u00e8s pouss\u00e9es (il est tout de m\u00eame assez rare de manipuler des matrices de 100000 lignes!), les probl\u00e8mes de pr\u00e9cision et de puissance sont encore au coeurs des probl\u00e9matiques actuelles.</p> <p>Nous commencerons ce cours en revenant sur la repr\u00e9sentration des nombres en machine pour montrer quelle impr\u00e9cisions sur les calculs elle peut engendrer. Puis nous nous int\u00e9resserons \u00e0 la compl\u00e8xit\u00e9 des algorithmes qui nous permettra de comprendre pourquoi des algorithmes seront plus performants que d'autres en terme de temps de calcul.</p>"},{"location":"2_Validite_logiciel_numerique/#validite-des-calculs-dans-un-ordinateur","title":"Validit\u00e9 des calculs dans un ordinateur","text":"<p>Si les informations tra\u00eet\u00e9es par un ordinateurs peuvent \u00eatre de diff\u00e9rentes nature (nombre, texte, etc.), elles sont repr\u00e9sent\u00e9es et manipul\u00e9es par l'ordinateur sous forme binaire (suite de 0 et de 1). Le bit (binary digit) est l'unit\u00e9 de base de la repr\u00e9sentation binaire. Chaque 0 ou 1 est un bit. \"1001\" est par exemple compos\u00e9 de 4 bits.</p> <p>Cette repr\u00e9sentation sous forme binaire a des cons\u00e9quences sur les r\u00e9sultats de certaines op\u00e9rations. L'op\u00e9ration \"0,1 + 0,1 + 0,1 - 0,3\" ne retourne par exemple pas exactement 0 en arithm\u00e9tique d'ordinateur.</p> <p>Dans ce chapitre, nous nous attarderons sur la repr\u00e9sentation des nombres en machine (et les op\u00e9rations associ\u00e9es), pour montrer comment elle peut induire des impr\u00e9cisions sur les r\u00e9sultats de certains calculs.</p>"},{"location":"2_Validite_logiciel_numerique/#les-differentes-bases-notations-utilisees","title":"Les diff\u00e9rentes bases - Notations utilis\u00e9es","text":"<p>Dans la vie courante, nous utilisons des chiffres de 0 \u00e0 9 : il s'agit de la base 10, compos\u00e9e de 10 symboles (les 10 chiffres). Nous parlerons aussi de base naturelle. Pour repr\u00e9senter un nombre en base 10, nous l'\u00e9crirons simplement, comme nous avons l'habitude de le faire (par exemple : 2016).</p> <p>Il est pourtant possible d'utiliser n'importe quelle autre base que la base 10.</p> <ul> <li>les \u00e9gyptiens utilisaient une base 12 (duodecimal) pour compter les heures   et les mois</li> <li>les mayas et azteques ont employ\u00e9 une base 20 (vig\u00e9simal). Au moyen \u00e2ge en   france on a \u00e9galement employ\u00e9 cette base (d'o\u00f9 le quatre-vingt).</li> <li>la base 60 (sexag\u00e9simal) \u00e9tait utilis\u00e9e par les sum\u00e9riens. Il sert toujours   pour mesurer les heures, minutes, secondes.</li> </ul> <p>Pour \u00e9crire un nombre dans une autre base que la base naturelle, nous l'\u00e9crirons entre parenth\u00e8ses et indiquerons la base en indice.</p> <p>Par exemple (146)<sub>8</sub> repr\u00e9sente le nombre 146 dans la base 8.</p> <p>Dans le domaine de l'infomatique, la base naturelle est la base 2, ou repr\u00e9sentation binaire. Les bases 8 et 16 (respectivement 8 et 16 symboles) sont \u00e9galement souvent utilis\u00e9es en informatique. En effet, ces bases sont des puissances de 2 et chaque symbole correspond exactement \u00e0 un groupe de bits (respectivement 3 et 4 bits) ce qui rend les conversions tr\u00e8s simples tout en apportant une \u00e9criture plus compacte que le binaire.</p> <p>En hexad\u00e9cimal (base 16), comme notre \u00e9criture ne comporte que 10 chiffres, nous utilisons des lettres pour compl\u00e9ter : 0 1 2 3 4 5 6 7 8 9 A B C D E F. \"A\" vaut 10, \"B\" 11, etc.</p> Hexad\u00e9cimal Valeur Binaire 0 0 0000 1 1 0001 2 2 0010 3 3 0011 4 4 0100 5 5 0101 6 6 0110 7 7 0111 8 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 <p>En octal (base 8), chaque symbole correspond \u00e0 un groupe de 3 bits. L'\u00e9criture est moins compacte que l'h\u00e9xad\u00e9cimal mais pr\u00e9sente l'avantage de ne pas requ\u00e9rir de symbole suppl\u00e9mentaire.</p> Octal Valeur Binaire 0 0 000 1 1 001 2 2 010 3 3 011 4 4 100 5 5 101 6 6 110 7 7 111"},{"location":"2_Validite_logiciel_numerique/#decomposition-dans-une-base-et-calcul-de-la-valeur-en-base-naturelle","title":"D\u00e9composition dans une base et calcul de la valeur en base naturelle","text":"<p>Pour comprendre comment s'effectue la d\u00e9composition d'un nombre exprim\u00e9 dans une base donn\u00e9e, nous partirons d'un exemple d'un nombre en base naturelle (base 10).</p> <p>Nous pouvons tous facilement \u00e9tablir que :</p> <p>2019 = 2 * 1000 + 0 * 100 + 1 * 10 + 6 * 1</p> <p>Si nous utilisont des puissances de 10, cela donne alors :</p> <p>2019 =  2 * 10<sup>3</sup>) + 0 * 10<sup>2</sup>) + 1 * 10<sup>1</sup>) + 9 * 10<sup>0</sup>)</p> <p>Qui est la d\u00e9composition en base 10 de 2019.</p> <p>La d\u00e9composition dans une autre base respecte le m\u00eame sch\u00e9ma. La d\u00e9composition de (146)<sub>8</sub> s'\u00e9crira ainsi :</p> <p>(146)<sub>8</sub> = 1 * 8<sup>2</sup>) + 4 * 8<sup>1</sup>) + 6 * 8<sup>0</sup>)</p> <p>Pour \u00e9valuer la valeur de ce nombre en base naturelle, il ne reste qu'\u00e0 \u00e9valuer les diff\u00e9rents termes de la d\u00e9composition :</p> <p>(146)<sub>8</sub> = 1 * 64 + 4 * 8 + 6 * 1 = 102</p> <p>(146)<sub>8</sub> est \u00e9gal \u00e0 102 en base naturelle.</p> <p>La d\u00e9composition des nombres d\u00e9cimaux n'apporte pas de changement majeurs. Pour comprendre comment cela fonctionne, revenons \u00e0 un exemple en base 10 :</p> <p>2019,125 = 2 * 1000 + 1 * 10 + 9 * 1 + 1 * 0,1 + 2 * 0,01 + 5 * 0,001</p> <p>Soit en utilisant des puissances de 10 :</p> <p>2019,125 = 2 * 10<sup>3</sup> + 1 * 10<sup>1</sup> + 9 * 10<sup>0</sup> + 1 * 10<sup>-1</sup> + 2 * 10<sup>-2</sup> + 5 * 10<sup>-3</sup></p> <p>Dans une autre base que la base naturelle, cela donnera par exemple :</p> <p>(1010,101)<sub>2</sub> = 1 * 2<sup>3</sup> + 0 * 2<sup>2</sup> + 1 * 2<sup>1</sup> + 0 * 2<sup>0</sup> + 1 * 2<sup>-1</sup> + 0 * 2<sup>-2</sup> + 1 * 2<sup>-3</sup></p> <p>Ce qui nous permet d'\u00e9valuer la nombre : (1010,101)<sub>2</sub> = 10,625</p> <p>Pour finir ce paragraphe, nous remarquerons que le principe reste le m\u00eame en hexad\u00e9cimal, m\u00eame si nous devons utiliser de nouveaux symboles :</p> <p>(2A3F)<sub>16</sub> = 2 * 16<sup>3</sup> + A * 16<sup>2</sup> + 3 * 16<sup>1</sup> + F * 16<sup>0</sup></p> <p>Soit en rempla\u00e7ant les lettres par leur valeurs en base 10 :</p> <p>(2A3F)<sub>16</sub> = 2 * 16<sup>3</sup> + 10 * 16<sup>2</sup> + 3 * 16<sup>1</sup> + 15 * 16<sup>0</sup> = 10815</p>"},{"location":"2_Validite_logiciel_numerique/#passage-de-la-base-naturelle-a-une-base-quelconque","title":"Passage de la base naturelle \u00e0 une base quelconque","text":"<p>Pouvoir utiliser toutes ces bases sera d'autant plus int\u00e9ressant si nous disposons de moyens pour passer d'une repr\u00e9sentation dans une base \u00e0 une repr\u00e9sentation dans une autre base. Dans le paragraphe pr\u00e9c\u00e9dent, nous avons montr\u00e9 comment d\u00e9composer un nombre \u00e9crit dans une base quelconque, ce qui permettait ensuite de l'\u00e9valuer. Ce faisant, nous avons r\u00e9alis\u00e9 le passage d'une base quelconque \u00e0 la base 10.</p> <p>Il nous reste \u00e0 effectuer l'op\u00e9ration inverse. Pour ce faire, nous allons utiliser une propri\u00e9t\u00e9 math\u00e9matique illustr\u00e9e par l'\u00e9galit\u00e9 suivante :</p> <p>2 * 16<sup>3</sup> + 10 * 16<sup>2</sup> + 3 * 16<sup>1</sup> + 15 * 16<sup>0</sup> = ((2 * 16 + 10) * 16 + 3) * 16 + 15</p> <p>Le principe de cette \u00e9galit\u00e9 va nous permettre de retrouver, par divisions enti\u00e8res successives, l'\u00e9criture dans une base quelconque.</p> <p>Division enti\u00e8re : soient a et b deux entiers positifs (b &gt; 0). Il exite un unique couple d'entiers positifs (q, r) tels que a = b * q + r avec 0 \u2264 r &lt; b. q est le quotient de la division enti\u00e8re de a par b et r est le reste de cette division enti\u00e8re.</p> <p>Pour \u00e9crire 10815 en base 16, nous commencerons donc par effectuer la division enti\u00e8re de 10815 par 16 :</p> <p>10815 = 675 * 16 + 15</p> <p>Puis nous repartons du quotient sur lequel nous effectuons \u00e0 nouveau une divison enti\u00e8re :</p> <p>675 = 42 * 16 + 3</p> <p>Et nous r\u00e9p\u00e9tons l'op\u00e9ration jusqu'\u00e0 ce que le quotient de la division enti\u00e8re soit nul :</p> <p>42 = 2 * 16 + 10</p> <p>2 = 0 * 16 + 2</p> <p>Pour reconstituer la repr\u00e9sentation en base 16, il ne nous reste plus qu'\u00e0 assembler les restes des divisions enti\u00e8res en partant du dernier vers le premier :</p> <p>10815 = (2 \"10\" 3 \"15\")<sub>16</sub> = (2A3F)<sub>16</sub></p> <p>Le principe est le m\u00eame pour convertir vers une n'importe quelle autre base. Par exemple, pour retrouver l'\u00e9criture en base de 2 de 52 :</p> <p>52 = 26 * 2 + 0</p> <p>26 = 13 * 2 + 0</p> <p>13 = 6 * 2 + 1</p> <p>6 = 3 * 2 + 0</p> <p>3 = 1 * 2 + 1</p> <p>1 = 0 * 2 + 1</p> <p>Soit au final :</p> <p>52 = (110100)<sub>2</sub></p> <p>Dans le cas de nombres \u00e0 virgules, nous distinguerons les parties enti\u00e8res et d\u00e9cimales et traiterons chacune d'elles de mani\u00e8re s\u00e9par\u00e9e. Nous savons d\u00e9j\u00e0 traiter la partie enti\u00e8re et il nous reste \u00e0 trouver une m\u00e9thode pour la partie d\u00e9cimale. Pour comprendre comment op\u00e9rer, repartons de la d\u00e9composition en base 10 de 0,125 :</p> <p>0,125 = 1 * 10<sup>-1</sup> + 2 * 10<sup>-2</sup> + 5 * 10<sup>-3</sup></p> <p>Comme pour la partie enti\u00e8re, nous pouvons factoriser les 10<sup>-1</sup> pour obtenir :</p> <p>0,125 = 10<sup>-1</sup> * ( 1 + 10<sup>-1</sup> * ( 2 + 10<sup>-1</sup> * 5))</p> <p>Pour \u00e9viter d'avoir \u00e0 manipuler des puissance n\u00e9gatives, prenons le probl\u00e8me dans l'autre sens :</p> <p>0,125 * 10 = 1 + 0,25</p> <p>0,25 * 10 = 2 + 0,5</p> <p>0,5 * 10 = 5 + 0,0</p> <p>A chaque \u00e9tape, nous s\u00e9parons ainsi les partie enti\u00e8res et d\u00e9cimale puis multiplions par la partie d\u00e9cimale par la base. La d\u00e9composition finale est \u00e9gale \u00e0 la suite des parties enti\u00e8res.</p> <p>Tentons par exemple de convertir 10,25 en base 2. Pour la partie enti\u00e8re, nous pouvons \u00e9tablir que :</p> <p>10 = (1010)<sub>2</sub></p> <p>Puis, pour la partie d\u00e9cimale :</p> <p>0,25 * 2 = 0 + 0,5</p> <p>0,5 * 2 = 1 + 0,0</p> <p>Ce qui donne donc pour la partie d\u00e9cimale :</p> <p>0,25 = (0,010)<sub>2</sub></p> <p>Soit au final en r\u00e9assemblant les deux parties :</p> <p>10,25 = (1010,010)<sub>2</sub></p>"},{"location":"2_Validite_logiciel_numerique/#un-premier-probleme-de-precision","title":"Un premier probl\u00e8me de pr\u00e9cision","text":"<p>Revennons ici \u00e0 notre probl\u00e9matique de d\u00e9part : les erreurs lors de certaines op\u00e9rations en mahcines. Pour ce faire, nous essayerons simplement de repr\u00e9senter 0,1 en base 2.</p> <p>0,1 * 2 = 0,2</p> <p>0,2 * 2 = 0,4</p> <p>0,4 * 2 = 0,8</p> <p>0,8 * 2 = 1,6</p> <p>0,6 * 2 = 1,2</p> <p>0,2 * 2 = 0,4</p> <p>0,4 * 2 = 0,8</p> <p>0,8 * 2 = 1,6</p> <p>0,6 * 2 = 1,2</p> <p>...</p> <p>Nous pourrions poursuivre ainsi ind\u00e9finiement! Au m\u00eame titre qu'il n'existe pas de repr\u00e9sentation exacte de 1/3 en base naturelle (1 / 3  \u2248  (0,333)<sub>10</sub>), il n'existe pas de r\u00e9pr\u00e9sentation exacte de 0,1 en base 2 : (0,2)<sub>10</sub>  \u2248  (0,00110011)<sub>2</sub>.</p>"},{"location":"2_Validite_logiciel_numerique/#arithmetique-dans-les-bases-differentes-de-la-base-naturelle","title":"Arithm\u00e9tique dans les bases diff\u00e9rentes de la base naturelle","text":"<p>montrer juste ici quelques exemples d'additions et soustraction en base 2, 8 et 16 par exemple</p>"},{"location":"2_Validite_logiciel_numerique/#representation-des-nombres-en-machine","title":"Repr\u00e9sentation des nombres en machine","text":"<p>Dans les paragraphes pr\u00e9c\u00e9dents nous avons vu comment passer d'une base \u00e0 une autre et comment effectuer des op\u00e9rations dans ces diff\u00e9rentes bases. Nous avons \u00e9galement montr\u00e9 comment traiter le cas des nombres d\u00e9cimaux. Si nous n'avons pas port\u00e9 une attention particuli\u00e8re aux nombres n\u00e9gatifs, c'est que ceux-ci ne pr\u00e9sentent pas de difficult\u00e9s particuli\u00e8res : il suffit d'ajouter le signe \"-\" devant le nombre \u00e0 repr\u00e9senter.</p> <p>Dans cette partie, nous nous concentrons sur la repr\u00e9sentation des nombres dans un ordinateur. La base utilis\u00e9e sera donc la base 2. Quelques sp\u00e9cificit\u00e9s propres \u00e0 l'architecture des ordinateurs viendront s'ajouter \u00e0 cette repr\u00e9sentation en binaire. Nous mettrons en \u00e9vidence les probl\u00e8mes r\u00e9sultants.</p> <p>Remarque : convention</p> <p>Dans cette partie, nous ne manipulerons que les bases 2 et 10 qui ne seront plus n\u00e9cessairement indiqu\u00e9es en indice des nombres.</p>"},{"location":"2_Validite_logiciel_numerique/#cas-des-nombres-negatifs","title":"Cas des nombres n\u00e9gatifs","text":"<p>Un premier probl\u00e8me se pose pour la r\u00e9pr\u00e9sentation des nombres n\u00e9gatifs en machine. En effet, un ordinateur ne parle que le binaire (0 et 1). Il devient donc inenvisageable d'utiliser un signe \"-\" qui n'est pas compris par l'ordinateur.</p> <p>La solution la plus simple consiste \u00e0 utiliser un nombre fixe de bits (g\u00e9n\u00e9ralement 8, 16, 32 ou 64 bits) et \u00e0 r\u00e9server celui le plus \u00e0 gauche (le bit de poids fort) pour le signe : 0 pour positif, 1 pour n\u00e9gatif.</p> <p>En appliquant cette r\u00e8gle et en utilisant un stockage sur 8 bits :</p> <ul> <li>2 = 00000010</li> <li>(-2) = 10000010</li> </ul> <p>Cette repr\u00e9sentation poss\u00e8de deux inconv\u00e9nients majeurs :</p> <ul> <li>le nombre 0 poss\u00e8de deux repr\u00e9sentations : 00000000 et 10000000;</li> <li>l'addition \"classique\" ne fonctionne plus si un des nombres est n\u00e9gatif :<ul> <li>(-3) = 10000011</li> <li>2 = 00000010</li> <li>Donc (-3) + 2 = 10000011 + 00000010 = 10000101, soit -5.</li> </ul> </li> </ul> <p>Afin d'am\u00e9liorer la repr\u00e9sentation, nous utiliserons alors une notation en compl\u00e9ment \u00e0 deux. Elle est obtenue de la mani\u00e8re suivante :</p> <ul> <li>les nombres positifs sont \u00e9crits normalement;</li> <li>pour les nombres n\u00e9gatifs :<ul> <li>inversion des bits de l'\u00e9criture binaire;</li> <li>ajout de 1 au r\u00e9sultat.</li> </ul> </li> </ul> <p>Par exemple, pour repr\u00e9senter -3 :</p> <ul> <li>3 = (00000011)<sub>2</sub></li> <li>inversion des bits : 11111100</li> <li>ajout de 1 : 11111101</li> <li>soit (-3) = 11111101</li> </ul> <p>L'op\u00e9ration (-3) + 2 est maintenant traduite en :</p> <p>11111101 + 00000010 = 11111111</p> <p>qui si l'on revient \u00e0 une repr\u00e9sentation en base naturelle donne :</p> <ul> <li>un nombre n\u00e9gatif (commence par un \"1\"), on enl\u00e8ve 1 : 11111110</li> <li>invertion des bits : 00000001</li> <li>soit finalement -1.</li> </ul> <p>Le r\u00e9sultat de l'addition en utilisant la repr\u00e9sentation en compl\u00e9ment \u00e0 deux est exact.</p> <p>Remarque : nombres minimum et maximum repr\u00e9sentables</p> <p>En utilisant le repr\u00e9sentation en compl\u00e9ment \u00e0 deux et un stockage sur e bits, (e-1) bits restent disponible pour indiquer la valeur du nombre. Celle-ci peut donc \u00eatre comprise entre -2<sup>e-1</sup> et 2<sup>e-1</sup> - 1.</p> <p>Par exemple :</p> <ul> <li>sur 8 bits : entre -128 et 127;</li> <li>sur 16 bits : entre -256 et 255.</li> </ul>"},{"location":"2_Validite_logiciel_numerique/#cas-des-nombres-decimaux","title":"Cas des nombres d\u00e9cimaux","text":"<p>De m\u00eame que pour les nombres n\u00e9gatifs, il n'est pas envisageable d'utiliser de virgule, non interpr\u00e9table par un ordinateur parlant le binaire, pour repr\u00e9senter les nombres d\u00e9cimaux.</p> <p>Nous avons par ailleurs vu que pour repr\u00e9senter les nombres n\u00e9gatifs en machine, nous utilisons un nombre de bits fixe en r\u00e9servant le bits de poids fort pour le signe.</p> <p>En s'inspirant de ce qui est fait pour les nombres n\u00e9gatifs, une premi\u00e8re approche pour repr\u00e9senter les nombres d\u00e9cimaux serait d'utiliser un nombre fixe de bits en en r\u00e9servant certains bits pour la partie enti\u00e8re et d'autres pour la partie d\u00e9cimale. Si cette repr\u00e9sentation est op\u00e9rationnelle, en pratique, nous constatons que les nombres manuipul\u00e9s poss\u00e8dent g\u00e9n\u00e9ralement :</p> <ul> <li>soit beaucoup de chiffres avant la virgule et peu apr\u00e8s   (ex : coordonn\u00e9e d'un point d'int\u00e9r\u00eat en Lambert 93);</li> <li>soit beaucoup de d\u00e9cimales mais peu de chiffres avant le virgules   (ex : longitudes/latitude en radian).</li> </ul> <p>Sans remettre en cause le fonctionnement de notre repr\u00e9sentation, cela pr\u00e9sente tout de m\u00eame quelques inconv\u00e9nients. Les nombres utiliseront soit beaucoup de bits pour la partie enti\u00e8re et peu pour la partie d\u00e9cimale, soit l'inverse. Il devient d\u00e8s lors difficile de r\u00e9server un nombre de bits ad\u00e9quats pour chacune des parties et nous utiliserons beaucoup d'espace pour stocker des 0.</p> <p>Pour palier aux limites de cette premi\u00e8re approche, nous utiliserons une repr\u00e9sentation en virgule flottante qui consiste \u00e0 utiliser une forme normalis\u00e9e de la repr\u00e9sentation binaire du type x =  a * 2<sup>n</sup> o\u00f9 :</p> <ul> <li>a est la mantisse comprise entre 1 et 2;</li> <li>n est un entier relatif appel\u00e9 exposant.</li> </ul> <p>Par exemple :</p> <p>9,5 = (1001,1)<sub>2</sub> = (1,0011)<sub>2</sub>*2<sup>3</sup></p> <p>Le stockage de ce nombre dans l'ordinateur s'effectuera alors sous la forme d'un triplet (signe, exposant, mantisse) avec :</p> <ul> <li>1 bit pour le signe : 0 pour positif / 1 pour n\u00e9gatif;</li> <li>e bits pour l'exposant;</li> <li>m bits pour la mantisse.</li> </ul> <p>La norme IEEE-754 d\u00e9finit plusieurs formats bas\u00e9s sur ce mod\u00e8le, diff\u00e9rant par la pr\u00e9cision de chacun d'eux :</p> <ul> <li>la simple pr\u00e9cision utilise 1 bit de signe, 8 d'exposant et 23 de mantisse</li> <li>la double pr\u00e9cison utilise 1 bit de signe, 11 d'exposant et 52 de mantisse</li> </ul> <p>Elle pr\u00e9cise \u00e9galement quelques r\u00e8gles am\u00e9liorant la pr\u00e9cision des nombres repr\u00e9sentables :</p> <ul> <li>en binaire, la partie enti\u00e8re de la mantisse vaut toujours 1. Seule la valeur   de la partie d\u00e9cimale sera donc stock\u00e9e;</li> <li>pour \u00e9viter d'avoir \u00e0 stocker des exposants n\u00e9gatifs, un d\u00e9calage de</li> <li>(2<sup>e-1</sup> - 1) est appliqu\u00e9 \u00e0 la valeur des exposants (127, par exemple, en   simple pr\u00e9cision).</li> </ul> <p>Pour calculer la valeur correspondant \u00e0 un triplet stock\u00e9 en respectant la norme IEEE-754, nous appliquerons finalement la formule :</p> <p>valeur = (-1)<sup>s</sup> * (m + 1) * 2<sup>e - decalage</sup></p> <p>o\u00f9 :</p> <ul> <li>s = 0 pour un nombre positif / 1 pour un nombre n\u00e9gatif</li> <li>m = nombre compris entre 0 et 1</li> <li>e = exposant d\u00e9cal\u00e9 compris entre -2<sup>e-1</sup> + 1 et 2<sup>e-1</sup></li> </ul> <p></p> <p>Par exemple :</p> <p>9,5 = 0  10000010  00110000000000000000000</p> <p>0,15625 = 0  01111100  01000000000000000000000</p> <p>-2,25 = 1  10000000  00100000000000000000000</p> <p>Quelques exceptions \u00e0 cette r\u00e8gle existent toutefois. En effet la repr\u00e9sentation n'est pas correcte pour les nombres valant 0 ou proche de 0. Si l'exposant vaut 0, la r\u00e8gle est alors de ne pas ajouter 1 \u00e0 la mantisse. De m\u00eame, si l'exposant vaut 2<sup>e - 1</sup>, la norme indique que le nombre vaut l'infini.</p> <p>Le tableau suivant r\u00e9sume les formes normalis\u00e9es/non normalis\u00e9es de la norme :</p> Exposant d\u00e9cal\u00e9 Mantisse Type 0 0 0 0 =! 0 (-1)<sup>s</sup>.m.2<sup>1-d</sup> de 1 \u00e0 2^e - 2 quelconque (-1)<sup>s</sup>.(m+1).2<sup>1-d</sup> 2^e - 1 0 infini 2^e - 1 =! 0 NaN"},{"location":"2_Validite_logiciel_numerique/#operations-sur-les-nombres-en-machine","title":"Op\u00e9rations sur les nombres en machine","text":"<p>La norme IEEE-754 consistant \u00e0 repr\u00e9senter les nombres sous une forme du type \\pm a * 2^n, l'addition de deux nombres ne sera possible que si leurs exposants sont identiques. L'op\u00e9ration consistera alors simplement \u00e0 additionner les mantisses.</p> <p>Une addition sera donc constitu\u00e9e de trois \u00e9tapes :</p> <ul> <li>alignement des mantisses afin d'avoir deux exposants \u00e9gaux</li> <li>addition des mantisses</li> <li>renormalisation si le r\u00e9sultat ne respecte plus la norme</li> </ul> <p>Au cours de ces \u00e9tapes, il faudra veiller \u00e0 g\u00e9rer correctement le bit implicite (partie enti\u00e8re de la mantisse non repr\u00e9sent\u00e9e dans la norme IEEE-754).</p> <p>Illustrons avec un exemple, en tentant de calculer 9,5 + 1,75 :</p> <p>9,5  = 0 10000010 00110000000000000000000</p> <p>1,75 = 0 01111111 11000000000000000000000</p> <p>L'exposant de 9,5 vaut 130 et celui de 1,75 vaut 127. Il faut donc d\u00e9caler la mantisse de 1,75 (plus petit exposant) de 3 vers la droite, sans oublire d'ins\u00e9rer le bit implicite (entre parenth\u00e8se si dessous) :</p> <p>0  01111111 (1) 11000000000000000000000</p> <p>0  10000010 (0) 00111000000000000000000</p> <p>Il est maintenant possible d'additionner les mantisses :</p> <p>0  10000010 (1) 00110000000000000000000 + 0  10000010 (0) 00111000000000000000000 \\= 0  10000010 (1) 01101000000000000000000</p> <p>La repr\u00e9sentation est d\u00e9j\u00e0 normalis\u00e9e (bit implicite valant 1). L'addition est termin\u00e9e.</p> <p>Pour contr\u00f4ler le r\u00e9sultat, \u00e9valuons le en base naturelle :</p> <p>0 10000010 01101000000000000000000</p> <p>= (-1)<sup>0</sup> * (1,01101)<sub>2</sub> * 2<sup>130-127</sup> = (1011,01)<sub>2</sub>  = 11,25</p> <p>Le r\u00e9sultat est correct !</p> <p>Autres exemples int\u00e9ressants (n\u00e9cessite de bien g\u00e9rer le bit implicite) :</p> <ul> <li>9,5 + 9,25</li> <li>9,875 - 1,75</li> <li>9,75 - 9,5</li> </ul>"},{"location":"2_Validite_logiciel_numerique/#limites-de-la-representation","title":"Limites de la repr\u00e9sentation","text":"<p>L'alignement des mantisses peut faire dispara\u00eetre des bits \"utiles\" (ie. diff\u00e9rents de 0) de la repr\u00e9sentation.</p> <p>Par exemple : * 9,5 + 1,7500001     * le 0,0000001 est perdu : cela revient \u00e0 additionner 9,5 + 1,75 * 10<sup>16</sup> + 0,1     * le 0,1 est perdu : cela revient \u00e0 additionner 0 * 9,500000953674316 - 9,5 * (1000000 + 0,01171875) - 1000000</p> <p>0,1 + 0,1 + 0,1 - 0,3.</p> <p>Les r\u00e9pr\u00e9sentation de 0,1 et 0,3 sont :</p> <p>0,1 = 0 01111011 10011001100110011001101</p> <p>0,3 = 0 01111101 00110011001100110011010</p> <p>On calcule 0,1+0,1 :</p> <p>0 01111011 ( 1) 10011001100110011001101 + 0 01111011 ( 1) 10011001100110011001101 \\= 0 10000010 (11) 00110011001100110011010</p> <p>On ajoute encore 0,1 :</p> <p>0 01111011 ( 11) 00110011001100110011010 + 0 01111011 (  1) 10011001100110011001101 \\= 0 10000010 (100) 11001100110011001100111</p> <p>Renormalisation de la mantisse de 0,1+0,1+0,1 :</p> <p>0 01111011 (100) 11001100110011001100111 0 01111101   (1) 00110011001100110011001</p> <p>Et on retire 0,3, le principe pour les soustractions \u00e9tant le m\u00eame que pour les additions (alignement des mantisses, op\u00e9ration sur les mantisses, renormalisation, le tout sans oublier de g\u00e9rer le bit implicite.</p> <p>Soustraction des mantisses :</p> <p>0 01111011 ( 1) 00110011001100110011001 - 0 01111101 ( 1) 00110011001100110011010 \\= 1 01111101 ( 0) 00000000000000000000001</p> <p>Il reste \u00e0 renormaliser la mantisse :</p> <p>1 01111101 (0) 00000000000000000000001 1 01100110 (1) 00000000000000000000000</p> <p>Soit en \u00e9valuant l'expression : -2<sup>-25</sup> = -3 * 10<sup>-8</sup></p>"},{"location":"2_Validite_logiciel_numerique/#representation-des-caracteres-en-machine","title":"Repr\u00e9sentation des caract\u00e8res en machine","text":"<p>Une cha\u00eene de caract\u00e8res est repr\u00e9sent\u00e9e comme une suite de caract\u00e8res. Le codage des caract\u00e8res est fait grace \u00e0 une table de correspondance indiquant l'\u00e9quivalent binaire de chacun des caract\u00e8res. La table de correspondance la plus utilis\u00e9e est l'ASCII (Am\u00e9rican Standard code for Information Interchange). Chaque caract\u00e8re y est repr\u00e9sent\u00e9 sur 7 bits. Notons que le code ASCII \u00e9tendu, utilisant 8 bits, permet de coder des caract\u00e8res suppl\u00e9mentaires (accents, etc.) non pr\u00e9sent initialement dans la langue anglaise.</p> <p>Le codage ASCII utilisant 7 bits, la table compl\u00e8te permet de repr\u00e9senter 128 caract\u00e8res (2^7). Les caract\u00e8res correspondant au codes 0 \u00e0 31 et 127 repr\u00e9sentant des caract\u00e8res de contr\u00f4les (retour \u00e0 la ligne ou autres actions sp\u00e9cifiques), restent 95 caract\u00e8res affichables.</p> <p></p> <p>Nous avons vu qu'il \u00e9tait courant, dans un ordinateur, de repr\u00e9senter les chiffres binaires sur un nombre fixe de bits (32 ou 64 bits pour la norme IEEE-754 par exemple). Ces repr\u00e9sentations trouvent ainsi une forme condens\u00e9e sur 4 ou 8 octets en hexadecimal, ce qui simplifie grandement l'\u00e9criture : 4 caract\u00e8res en hexad\u00e9cimal contre 32 en binaire...</p> <p>Exemple : Extrait de la table ASCII</p> En base 10 En base 16 En base 2 Symbole ASCII D\u00e9tail 63 3F 00111111 ? Point d'interrogation 64 40 01000000 @ Arobase8 65 41 01000001 A Lettre latine capitale A 66 42 01000010 B Lettre latine capitale B 67 43 01000011 C Lettre latine capitale C"},{"location":"2_Validite_logiciel_numerique/#complexite-en-algorithmie","title":"Complexit\u00e9 en algorithmie","text":"<p>La th\u00e9orie de la complexit\u00e9 algorithmique s'int\u00e9resse \u00e0 l'estimation de l'efficacit\u00e9 des algorithmes. Elle s'attache \u00e0 r\u00e9pondre \u00e0 diverses questions sur un algorithme :</p> <ul> <li>l'algorithme apporte-t-il une r\u00e9ponse au probl\u00e8me pos\u00e9 ? C'est la notion de terminaison</li> <li>l'algorithme apporte-t-il la bonne r\u00e9ponse au probl\u00e8me pos\u00e9 ? Notion de validit\u00e9</li> <li>l'algorithme apporte-t-il la bonne r\u00e9ponse dans un temps acceptable ? Notion de complexit\u00e9</li> </ul> <p>Afin de d\u00e9finir pr\u00e9cis\u00e9ment ces trois notions, commen\u00e7ons par red\u00e9finir de mani\u00e8re plus math\u00e9matique un algorithme.</p> <p>Un algorithme est form\u00e9 d'un ensemble fini d'op\u00e9rations li\u00e9es par une structure de contr\u00f4le et dont les op\u00e9randes portent sur un ensemble fini de variables.</p> <p>Un algorithme r\u00e9soud le probl\u00e8me qui est pos\u00e9 si la suite des op\u00e9rations est finie (condition de terminaison) et si, lors de la terminaison, le sous-ensemble des variables de sortie contient le r\u00e9sultat du probl\u00e8me (condition de validit\u00e9).</p> <p>Prouver un algorithme c'est d\u00e9montrer math\u00e9matiquement que les conditions de terminaison et de validit\u00e9 sont satisfaites.</p> <p>S'int\u00e9resser \u00e0 l'estimation du nombre d'op\u00e9rations n\u00e9cessaires, \u00e0 une constante pr\u00e8s, pour r\u00e9soudre le probl\u00e8me sur un sous-ensemble de taille fixe n, c'est \u00e9tablir la classe de complexit\u00e9 de l'algorithme.</p>"},{"location":"2_Validite_logiciel_numerique/#terminaison-et-validite","title":"Terminaison et validit\u00e9","text":"<p>Nous illustrerons par quelques exemples la d\u00e9monstration des preuves de terminaison et de validit\u00e9 d'un algorithme.</p> <p>Consid\u00e9rons l'algorithme effectuant la somme des \u00e9l\u00e9ments d'un tableau.</p> <pre><code>Fonction somme (tableau, taille)\n  resultat = 0\n  Pour i allant de 1 \u00e0 taille\n    rasultat = resultat + tableau[i]\n  Fin pour\n  Retourner resultat\nFin fonction\n</code></pre> <p>La terminaison est \u00e9vidente puisque l'algorithme est constitu\u00e9e d'une boucle qui ex\u00e9cute n fois une somme et une affectation (op\u00e9rations s'ex\u00e9cutant en temps fini).</p> <p>Pour d\u00e9montrer la validit\u00e9, nous proc\u00e9dons par r\u00e9currence sur la taille du tableau. Nous devons d\u00e9montrer que la formule S(n) = \u2211T<sub>i</sub> (pour i allant jusqu'\u00e0 n).</p> <ul> <li>Si le tableau est compos\u00e9 de zero \u00e9l\u00e9ment, la somme est initialis\u00e9e \u00e0 0 avant la boucle et la boucle est parcourue 0-fois. La somme est donc correcte.</li> <li>Si le tableau est compos\u00e9 d'un \u00e9l\u00e9ment, la somme calcul\u00e9e par l'algorithme est toujous correcte : elle est initialis\u00e9e \u00e0 0 pour T<sub>1</sub> est ajout\u00e9 (S = 0 + T<sub>1</sub> = T<sub>1</sub>), ce qui est correct.</li> <li>Si l'algorithme est vrai pour un tableau de p \u00e9l\u00e9ments, nous devons d\u00e9montrer qu'elle l'est pour un tableau de p+1 \u00e9l\u00e9ments. S(p+1) = S(p) + T(p+1) =  \u2211T<sub>i</sub>. La formule est donc correcte.</li> </ul>"},{"location":"2_Validite_logiciel_numerique/#complexite","title":"Complexit\u00e9","text":""},{"location":"2_Validite_logiciel_numerique/#petit-historique","title":"Petit historique","text":"<p>A l'origine des analyses de complexit\u00e9 algorithmique, on indiquait, pour chaque algorithme trouv\u00e9, le temps de calcul pour un nombre donn\u00e9e d'\u00e9l\u00e9ments en entr\u00e9e, sur un processeur et avec un langage donn\u00e9s. Cette m\u00e9thode souffrait d'une grande faiblaisse : il \u00e9tait quasiment impossibilit\u00e9 de comparer les algorithmes entre eux.</p> <p>La n\u00e9cessit\u00e9 de disposer d'une approche ind\u00e9pendante des facteurs mat\u00e9riels s'est alors fait sentir.</p> <p>L'id\u00e9e de compter le nombre d'op\u00e9rations \u00e9l\u00e9mentaires d'un algorithme est alors apparue.</p> <p>La taille des donn\u00e9es pouvant avoir un impact sur la performance d'un algorithme, elle peut \u00e9galement \u00eatre prise en compte.</p>"},{"location":"2_Validite_logiciel_numerique/#notion-de-complexite","title":"Notion de complexit\u00e9","text":"<p>La complexit\u00e9 mesure le nombre d'op\u00e9rations fondamentales qu'effectue un algorithme sur un jeu de donn\u00e9es pour aboutir au r\u00e9sultat. Elle est exprim\u00e9e en fonction de la taille du jeu de donn\u00e9es, souvent not\u00e9 n.</p> <p>Nous ne nous int\u00e9resserons ici qu'\u00e0 des jeux de donn\u00e9es de grande taille (n &gt; 1000). En effet, lorsque les jeux de donn\u00e9es sont petits les ordinateurs actuels sont suffisamment puissant pour retourner un r\u00e9sultat en quelques millisecondes, m\u00eame lorsque l'algorithme est mauvais. Nous dirons parfois que la complexit\u00e9 mesure la performance asymptotique d'un algorithme pour signifier qu'il s'agit de la performance lorsque la taille du jeu de donn\u00e9es tend vers l'infini.</p> <p>Les op\u00e9rations \u00e9l\u00e9mentaires dont il est questions pour \u00e9valuer la complexit\u00e9 d'un algorithme sont au nombre de quatre : * adition, soustraction, multiplication, division * acc\u00e8s m\u00e9moire * comparaisons * calculs sur les pointeurs</p> <p>Nous distinguons trois types de complexit\u00e9 :</p> <ul> <li>la complexit\u00e9 dans le meilleur des cas : plus petit nombre d'op\u00e9rations qu'aura \u00e0 effectuer l'algorithme sur le jeu de donn\u00e9es;</li> <li>la complexit\u00e9 dans le pire des cas : plus grand nombre d'op\u00e9rations qu'aura \u00e0 effectuer l'algorithme sur le jeu de donn\u00e9es;</li> <li>la complexit\u00e9 dans le cas moyen : moyenne des nombres d'op\u00e9rations de l'algorithme sur des jeux de donn\u00e9es de m\u00eame taille.</li> </ul> <p>C'est g\u00e9n\u00e9ralement l'analyse de la complexit\u00e9 dans le pire des cas qui focalisera l'attention. En effet nous observons que les algorithmes fonctionnent souvent dans des situations les plus mauvaises pour eux. L'analyse du pire des cas nous fournit alors une limite sup\u00e9rieure de temps de calculs : les performances seront toujours meilleures que dans ce cas. Dans la suite de ce cours, nous ne nous int\u00e9resserons qu'\u00e0 la complexit\u00e9 dans le pire des cas.</p> <p>Lorsque plusieurs algorithmes retournent le m\u00eame r\u00e9sultat \u00e0 partir d'un jeu de donn\u00e9es (par exemple les diff\u00e9rents algorithmes de tri), l'algorithme est dit optimal si sa complexit\u00e9 est la plus faible de tous.</p>"},{"location":"2_Validite_logiciel_numerique/#notations-de-landau","title":"Notations de Landau","text":"<p>La notation de Landau est utilis\u00e9e pour d\u00e9finir rigoureusement la notion de complexit\u00e9.</p> <ul> <li>O(f) pour le pire des cas</li> <li>Omega(f) pour le meilleur des cas</li> <li>Theta(f) pour le cas moyen</li> </ul> <p>Pour le pire des cas, qui nous int\u00e9resse ici exclusivement, cette notation exprime une borne sup\u00e9rieure d'une fonction.</p> <p>Si le nombre d'op\u00e9ration effectu\u00e9 par l'algorithme suit une fonction f(n), nous noterons O(g(n)) la complexit\u00e9 de l'algorithme avec f(n) = 0(g(n)).</p> <p></p> <p>Les r\u00e8gles suivantes s'appliquent lorsque l'on effectue des op\u00e9rations :</p> <ul> <li>les constantes multiplicatives sont omises : O(c * g(n)) = c * O(g(n) = O(g(n))</li> <li>ainsi les termes constants sont not\u00e9s O(1) (O(k) = O(k * 1) = O(1))</li> <li>l'addition est r\u00e9alis\u00e9e en ne retenant que le maximum : O(f(n) + g(n)) = O(f(n)) + O(g(n)) = max(O(f(n)), O(g(n)))</li> <li>la multiplication est \"classique\" : O(f(n) * g(n)) = O(f(n)) * O(g(n))</li> </ul> <p>Par exemple, si un algorithme pr\u00e9sente une complexit\u00e9 dans le pire des cas fonction de g(n) = 3 * n<sup>3</sup> + 10 * n<sup>2</sup> + 5, elle sera not\u00e9 O(n<sup>3</sup>).</p>"},{"location":"2_Validite_logiciel_numerique/#classes-de-complexite","title":"Classes de complexit\u00e9","text":"<p>Les complexit\u00e9s que l'on rencontre fr\u00e9quemment sont les suivantes :</p> <ul> <li>O(1) : acc\u00e8s constant</li> <li>O(log(n)) : logarithmique</li> <li>O(n) : lin\u00e9aire</li> <li>O(n.log(n)) : quasi-lin\u00e9aire</li> <li>O(n<sup>2</sup>) : quadratique</li> <li>O(n<sup>3</sup>) : cubique</li> <li>O(n<sup>p</sup>) : polynomiale</li> <li>O(2<sup>n</sup>) : exponentielle</li> <li>O(n!) : factorielle</li> </ul> <p></p> <p>Le tableau ci-dessous fournit des temps d'ex\u00e9cution en secondes pour le diff\u00e9rentes classes de complexit\u00e9 et diff\u00e9rentes tailles de donn\u00e9es, en consid\u00e9rant que l'ordinateur traite 10<sup>6</sup> instructions par secondes (10<sup>6</sup> FLOPS; ce qui correspond \u00e0 un ordinateur bureautique classique en 2016).</p> n 10 20 30 60 log(n) 2,3.10<sup>-6</sup> 3,0.10<sup>-6</sup> 3,4.10<sup>-6</sup> 4,09.10<sup>-6</sup> n 1.10<sup>-5</sup> 2.10<sup>-5</sup> 3.10<sup>-5</sup> 6.10<sup>-5</sup> n.log(n) 2,3.10<sup>-5</sup> 5,99.10<sup>-5</sup> 1,02.10<sup>-4</sup> 2,46.10<sup>-4</sup> n<sup>2</sup> 10<sup>-4</sup> 4.10<sup>-4</sup> 9.10<sup>-4</sup> 3,6.10<sup>-3</sup> n<sup>3</sup> 10<sup>-3</sup> 8.10<sup>-3</sup> 2,7.10<sup>-2</sup> 2,16.10<sup>-1</sup> 2<sup>n</sup> 1,02.10<sup>-3</sup> 1,05 1,07.10<sup>3</sup> 1,15.10<sup>12</sup> n! 3,6 2,4.10<sup>12</sup> 2,4.10<sup>26</sup> 8,3.10<sup>75</sup> <p>Il est int\u00e9ressant de remarquer que 10<sup>12</sup> secondes \u00e9quivaut \u00e0 environ 36 000 annn\u00e9es !</p>"},{"location":"2_Validite_logiciel_numerique/#calculs-de-complexite","title":"Calculs de complexit\u00e9","text":"<p>Dans ce paragraphe, nous donnons les \u00e9l\u00e9ments de base permettant de calculer la complexit\u00e9 d'un algorithme.</p> <ul> <li> <p>Une instruction simple (lecture, \u00e9criture, affectation...) s'effectue en acc\u00e8s constant : O(1)</p> </li> <li> <p>Dans le cas d'une suite d'instructions simples, la complexit\u00e9 est \u00e9gale \u00e0 la somme des complexit\u00e9s.</p> </li> </ul> Instructions Complexit\u00e9 a = 2 O(1) b = 3 O(1) c = a + b O(1) <p>Complexit\u00e9 r\u00e9sultante : O(1)+O(1)+O(1) = max(O(1), O(1), O(1)) = O(1)</p> <ul> <li>Dans le cas d'un traitement conditionnel, la complexit\u00e9 au pire des cas est retenue est celle du bloc d'instructions le moins performant :</li> </ul> Instructions Complexit\u00e9 Si condition O(condition) -- instructionsA O(instructionsA) sinon -- insctructionsB O(instructionsB) fin si Complexit\u00e9 r\u00e9sultante : O(condition) + max(O(instructionsA), O(instructionsB)) <ul> <li>Dans le cas d'une structure it\u00e9rative, la complexit\u00e9 est celle du bloc d'instructions de la boucle multipli\u00e9 par le nombre d'it\u00e9rations.</li> </ul> Instructions Complexit\u00e9 Pour i allant de p \u00e0 q -- instructions (q-p)*O(instructions) Fin pour <p>Pour illustrer \u00e9valuons la complexit\u00e9 de l'algorithme de calcul de la factorielle :</p> Instructions Complexit\u00e9 Fonction factorielle(n) -- res = 1 O(1) -- Si n \u2260 0 O(1) ---- Pour i allant de 1 \u00e0 n ------ res = res * i n*O(1) ---- Fin pour -- Fin si -- Retourner res Fin fonction <p>La complexit\u00e9 est donc en O(1) + O(1) + max(O(1), O(0)) + n*O(1) = O(n)</p>"},{"location":"2_Validite_logiciel_numerique/#application-comparaison-de-divers-algorithmes-de-tri","title":"Application : comparaison de divers algorithmes de tri","text":"<ul> <li>tri par s\u00e9lection (trouver le plus petit et le mettre au d\u00e9but)</li> <li>tri par s\u00e9lection r\u00e9cursif (trouver le plus grand, le mettre \u00e0 la fin et recommancer sur le tableau 0:n-1)</li> <li>tri par insertion (tri des 2 premiers \u00e9l\u00e9ments, insertion du 3\u00e8me, etc.)</li> <li>tri fusion (d\u00e9couper en deux et trier chaque partie puis fusionner)</li> <li>tri \u00e0 bulles (comparer chaque \u00e9l\u00e9ment \u00e0 son suivant et recommencer)</li> <li>tri rapide (choisir un pivot, placer les plus petits avant, les plus grands apr\u00e8s et trier chaque partie)</li> </ul> <p>Illustration en codant les algorithmes sous Python (plateforme de test : Ubuntu 14.04 64bits / 7,7Gio RAM / Intel\u00ae Core\u2122 i5-3337U CPU @ 1.80GHz \u00d7 4  / Python 3.4). Moyennes sur 10 ex\u00e9cutions de tri d'un tableau de 10000 entiers al\u00e9atoires entre 0 et 1000 :</p> <ul> <li>Tri par s\u00e9lection : 3.2706s</li> <li>Tri par s\u00e9lection r\u00e9cursif : 3.1255s</li> <li>Tri par insertion : 4.0774s</li> <li>Tri fusion : 0.0434s</li> <li>Tri \u00e0 bulles : 5.2502s</li> <li>Tri rapide : 0.000005s</li> </ul>"},{"location":"3.b_diviser_pour_regner/","title":"Approche 'diviser pour mieux r\u00e8gner'","text":""},{"location":"3.b_diviser_pour_regner/#approche-diviser-pour-regner","title":"Approche diviser pour r\u00e9gner","text":"<p>Pour r\u00e9soudre certains types de probl\u00e8mes complexes, il peut \u00eatre utile de le diviser en sous-probl\u00e8mes plus faciles \u00e0 r\u00e9soudre pour ensuite les combiner dans la solution finale.</p> <p></p> <p>Cette approche peut \u00eatre utilis\u00e9e pour des algorithme de tri qu'on verra plus tard dans le cours, et dans de nombreux autre algorithmes.</p>"},{"location":"3.b_diviser_pour_regner/#exemple-recherche-dichotomique","title":"Exemple : recherche dichotomique","text":"<p>Vous souvenez-vous de l'exercice sur le \"nombre myst\u00e8re\" ? Quelle strat\u00e9gie devait-on employer pour trouver le plus rapidement le nombre en question ?</p> <p>La probl\u00e9matique de la recherche dichotomique est de trouver la position d'une valeur recherch\u00e9e dans un tableau tri\u00e9.</p> <p>Par exemple : - J'ai en entr\u00e9e le tableau tri\u00e9 [1, 6, 15, 16, 20, 25, 102, 150, 1002] - Je veux savoir la position du nombre 16 dans ce tableau - La r\u00e9ponse recherch\u00e9e est donc 3 (car on commence \u00e0 0)</p> <p></p> <p>Les \u00e9tapes sont les suivantes : - Je compare la valeur recherch\u00e9e avec la valeur \u00e0 la moiti\u00e9 du tableau - Si les deux valeurs sont \u00e9gales, j'ai trouv\u00e9 la solution, la position recherch\u00e9e est la position du milieu du tableau - Si ma valeur est plus \u00e9lev\u00e9e que celle au milieu du tableau, je prends la deuxi\u00e8me moiti\u00e9 du tableau et je recommence - Si ma valeur est plus faible que celle au milieu du tableau, je prends la premi\u00e8re moiti\u00e9 du tableau et je recommence</p> <p>Comment \u00e9crire cet algorithme en pseudo-code ? En mode r\u00e9cursif ?</p>"},{"location":"3.c_exercices_algo/","title":"Exercices d'Algorithmie","text":""},{"location":"3.c_exercices_algo/#exercices-de-mise-en-pratique-de-lalgorithmique","title":"Exercices de mise en pratique de l'algorithmique","text":"<p>Il s'agira dans les exercices suivants d'\u00e9crire une (ou plusieurs) fonction(s) r\u00e9pondant \u00e0 la probl\u00e9matique.</p>"},{"location":"3.c_exercices_algo/#permutation","title":"Permutation","text":"<p>\u00c9crire une fonction qui permute les valeurs attribu\u00e9es \u00e0 deux variables.</p>"},{"location":"3.c_exercices_algo/#parite","title":"Parit\u00e9","text":"<p>\u00c9crire une fonction qui d\u00e9termine la parit\u00e9 de la valeur attribu\u00e9e \u00e0 une variable.</p>"},{"location":"3.c_exercices_algo/#tableaux","title":"Tableaux","text":"<p>Les exercices suivants porteront sur des tableaux, structure de donn\u00e9e composite abord\u00e9e pendant le cours. Par exemple <code>tabl = [1, 2, 3]</code> est un tableau de longueur 3. Pour acc\u00e9der \u00e0 ses \u00e9l\u00e9ments, on utilisera la notation suivante : <code>tabl[i]</code> (avec <code>i</code> commen\u00e7ant \u00e0 0) Ainsi : <code>tabl[0]</code> vaut <code>1</code> et <code>tabl[3]</code> n'existe pas.</p> <p>Dans les exercices suivants, on consid\u00e8rera un tableau de nombres entiers et de longueur <code>long</code>.</p>"},{"location":"3.c_exercices_algo/#somme","title":"Somme","text":"<p>\u00c9crire une fonction qui calcule la somme de tous les \u00e9l\u00e9ments du tableau</p>"},{"location":"3.c_exercices_algo/#maximum","title":"Maximum","text":"<p>\u00c9crire une fonction qui calcule le maximum de tous les \u00e9l\u00e9ments du tableau</p>"},{"location":"3.c_exercices_algo/#minimum","title":"Minimum","text":"<p>\u00c9crire une fonction qui calcule le minimum de tous les \u00e9l\u00e9ments du tableau</p>"},{"location":"3.c_exercices_algo/#moyenne","title":"Moyenne","text":"<p>\u00c9crire une fonction qui calcule la moyenne des \u00e9l\u00e9ments du tableau</p>"},{"location":"3.c_exercices_algo/#mediane","title":"M\u00e9diane","text":"<p>\u00c9crire une fonction qui calcule la m\u00e9diane des \u00e9l\u00e9ments du tableau</p>"},{"location":"3.c_exercices_algo/#tri","title":"Tri","text":"<p>\u00c9crire une proc\u00e9dure qui trie les valeurs du tableau dans l'ordre croissant et renvoie un nouveau tableau</p>"},{"location":"3.c_exercices_algo/#factorielle","title":"Factorielle","text":"<p>La factorielle du nombre n, not\u00e9e <code>n!</code> est le produit de tous les nombres entiers cons\u00e9cutifs jusqu'\u00e0 n.</p> <p>\u00c9crire une fonction qui calcule la factorielle du nombre n. R\u00e9\u00e9crire cette fonction en mode r\u00e9cursif.</p>"},{"location":"3.c_exercices_algo/#nombre-mystere-jeu-de-plus-ou-moins","title":"Nombre myst\u00e8re (jeu de \"plus ou moins\")","text":"<p>Nouvelles instructions : Afficher et Entrer Pour afficher de la donn\u00e9e, un algorithme pourra utiliser l'instruction Afficher <code>Afficher ma_variable</code> Pour affecter une valeur entr\u00e9e par l'utilisateur \u00e0 une variable, on pourra utiliser l'instruction Entrer <code>Entrer ma_variable</code></p> <p>Exemple : le programme suivant affiche la somme de 2 et d'un nombre entr\u00e9 par l'utilisateur <pre><code>Entrer nombre\nAfficher nombre + 2\n</code></pre></p> <p>\u00c0 l'aide de ces nouvelles instructions, cr\u00e9er une proc\u00e9dure qui prend en entr\u00e9e un nombre n, qui calcule un nombre al\u00e9atoire entre 0 et n, et qui tente de le faire deviner \u00e0 l'utilisateur en lui indiquant si la valeur \u00e0 deviner est plus \u00e9lev\u00e9e ou plus faible que la derni\u00e8re valeur entr\u00e9e.</p> <p>On pourra utiliser la fonction nombre_aleatoire(inf, sup) qui renvoie un nombre entier al\u00e9atoire entre inf et sup</p>"},{"location":"3_Algorithmie/","title":"Introduction \u00e0 l'algorithmie","text":""},{"location":"3_Algorithmie/#objectifs","title":"Objectifs","text":"<ul> <li>Savoir \u00e9crire des algorithmes en pseudo code;</li> <li>Notamment, des applications aux cas de la g\u00e9omatique.</li> </ul>"},{"location":"3_Algorithmie/#pre-requis","title":"Pr\u00e9-requis","text":"<p>Aucun</p>"},{"location":"3_Algorithmie/#introduction-a-lalgorithmie","title":"Introduction \u00e0 l'algorithmie","text":"<p>Les grandes phases de la conception d'un programme sont : l'analyse, l'algorithmie et la programmation.</p> <p></p> <p>Cette partie du cours se concentre sur la seconde phase : l'\u00e9criture d'algorithmes. Les m\u00e9thodes d'analyse seront \u00e9tudi\u00e9es ult\u00e9rieurement. Pour la programmation, nous nous appuierons sur le langage Python pour illustrer lors de ce cours la derni\u00e8re phase de r\u00e9alisation d'un logiciel.</p> <p>La programmation doit se r\u00e9sumer \u00e0 transposer dans un langage de programmation des algorithmes d\u00e9j\u00e0 \u00e9crits lors de la formulation de la solution.</p>"},{"location":"3_Algorithmie/#definition","title":"D\u00e9finition","text":"<p>Un algorithme est l'expression claire et condens\u00e9e d'un ensemble de traitements \u00e0 effectuer pour r\u00e9soudre un probl\u00e8me.</p> <p>Comme pour les langages de programmation, il existe diff\u00e9rents langages d'algorithmie (comme le pseudo-code paar exemple qui est souvent utilis\u00e9). Dans ce cours nous utiliserons le langage ADL qui pr\u00e9sente l'avantage de poss\u00e9der une syntaxe tr\u00e8s concise et plus abstraite.</p> <p>Un programme est l'impl\u00e9mentation d'un algorithme dans un langage de programmation donn\u00e9. L'algorithme se diff\u00e9rencie notamment du programme par son ind\u00e9pendance \u00e0 l'architecture d'une machine : on n'a par exemple pas \u00e0 se soucier dans un algorithme de la gestion de la m\u00e9moire comme on devrait le faire en C.</p> <p>L'int\u00e9r\u00eat de passer par une phase d'algorithmie avant de commencer \u00e0 coder est donc de pouvoir se concentrer sur les m\u00e9thodes plut\u00f4t que sur les sp\u00e9cificit\u00e9s d'un langage de programmation.</p> <p>Pour \u00e9crire des algorithmes, nous utiliserons un pseudo-code, c'est-\u00e0-dire des instructions \u00e9crites ne d\u00e9pendant d'aucun langage de programmation.</p>"},{"location":"3_Algorithmie/#variable-et-affectation","title":"Variable et affectation","text":"<p>Pour r\u00e9soudre un probl\u00e8me, un algorithme d\u00e9crit une suite d'op\u00e9rations \u00e0 effectuer. Pour ce faire, nous allons avoir besoin de manipuler des valeurs (r\u00e9sultats de calculs, donn\u00e9es saisies par l'utilisateur...). A chaque fois que nous aurons besoin de stocker une information, nous utiliserons une variable.</p> <p>Une variable permet d'associer un nom \u00e0 une valeur, cette derni\u00e8re pouvant \u00e9voluer au cours de l'algorithme.</p> <p>De mani\u00e8re imag\u00e9e, une variable est une bo\u00eete, identifi\u00e9e \u00e0 l'aide d'une \u00e9tiquette (son nom), dans laquelle une donn\u00e9e (sa valeur) peut \u00eatre stock\u00e9e. Bien entendu, un ordinateur n'est pas compos\u00e9 de bo\u00eete, ni d'\u00e9tiquettes : la m\u00e9moire de l'ordinateur est compos\u00e9e d'emplacement rep\u00e9r\u00e9 par leur adresse binaire.</p> <p>L'instruction qui permet de cr\u00e9er une variable, c'est \u00e0 dire de lui donner un nom, est appell\u00e9e la d\u00e9claration. En programmation, avec certains langages, il ne suffit pas de donner un nom \u00e0 une variable pour pouvoir la d\u00e9clarer : il faut \u00e9galement pr\u00e9ciser le type de donn\u00e9es qu'elle contiendra. Cet aspect ne concerne pas l'algorithmie.</p> <p>Le nom de la variable est compos\u00e9 de lettres majuscules ou minuscules (la distinction est respect\u00e9e), des chiffres et le caract\u00e8re blanc soulign\u00e9. Il ne peut commencer que par une lettre. Le caract\u00e8re blanc soulign\u00e9 ne peut \u00eatre \u00e9crit deux fois cons\u00e9cutivement, ni terminer le nom de variable. On parle \u00e9galement d'identificateur pour le nom de variable.</p> <p>L'affectation est, quand \u00e0 elle, l'op\u00e9ration consistant \u00e0 associer une valeur \u00e0 une variable.</p> <p>On utilisera comme symbole de l'affectation le symbole <code>=</code></p> <p>Exemple : j'affecte la valeur 4 \u00e0 la variable mon_entier <pre><code>mon_entier = 4\n</code></pre></p>"},{"location":"3_Algorithmie/#operateurs-et-expressions","title":"Op\u00e9rateurs et expressions","text":"<p>Un op\u00e9rateur est un signe qui relie deux valeurs pour produire un r\u00e9sultat.</p> <p>Assez naturellement les op\u00e9rateurs d\u00e9pendent du types des valeurs sur lesquels ils s'appliquent : diviser des cha\u00eenes de caract\u00e8res n'a pas de sens par exemple.</p> <p>Nous ne pr\u00e9senterons dans ce paragraphe que les op\u00e9rateurs de base, d\u00e9j\u00e0 connus de tous, sans rechercher l'exhaustivit\u00e9. Nous introduirons petit \u00e0 petit dans la suite du cours les diff\u00e9rents op\u00e9rateurs qui nous seront utiles.</p> <ul> <li>op\u00e9rateurs arithm\u00e9tiques : + - * / ^ % (modulo)</li> <li>comparateurs : &lt; &lt;= = != &gt;= &gt;</li> <li>op\u00e9rateurs logiques : ET OU NON</li> <li>op\u00e9rateur de concat\u00e9nation : &amp;</li> </ul> <p>Une expression repr\u00e9sente une succession d'op\u00e9rations sur des valeurs. Le r\u00e9sultat de l'expression \u00e9quivaut \u00e0 une seule valeur.</p> <p>Exemple :</p> <ul> <li>4 + 3</li> <li>\"bla\" &amp; \"bla\" &amp; \"bla\"</li> </ul>"},{"location":"3_Algorithmie/#instructions","title":"Instructions","text":"<p>Une instruction d\u00e9signe une \u00e9tape d'un algorithme.</p> <p>L'affectation est un exemple d'instruction : <code>a = 4</code>. Les boucles ou tests que nous \u00e9tudierons dans les prochaines parties sont d'autres types d'instructions de base qui sont fr\u00e9quement utilis\u00e9es en algorithmie.</p> <p>Consid\u00e9rons l'algorithme suivant : <pre><code>a = 4\nb = 2\nc = a + b\n</code></pre></p> <p>Il est compos\u00e9 de 3 instructions : 2 affectations et une op\u00e9ration qui permet d'effectuer la somme des deux variables a et b pour l'affecter \u00e0 une troisi\u00e8me (c).</p> <p>Nous entendrons parfois parler de bloc d'instructions. Il s'agit simplement de plusieurs instructions qui sont ex\u00e9cut\u00e9es successivement. Un algorithme est ainsi constitu\u00e9 d'un ou plusieurs blocs d'instructions.</p>"},{"location":"3_Algorithmie/#boucles","title":"Boucles","text":"<p>La notion de boucle est fondamentale en algorithmie.</p> <p>Une boucle permet de r\u00e9p\u00e9ter plusieurs fois un bloc d'instructions.</p> <p>Imaginons que nous voulions ajouter 1 aux valeurs contenues dans un tableau T de trois \u00e9l\u00e9ments (T<sub>0</sub>, T<sub>1</sub> et T<sub>2</sub>). L'algorithme na\u00eff serait le suivant :</p> <p>T<sub>0</sub> = T<sub>0</sub> + 1; T<sub>1</sub> = T<sub>1</sub> + 1; T<sub>2</sub> = T<sub>2</sub> + 1;</p> <p>Nous recopions en fait trois fois quasiment la m\u00eame chose, ce qui est inutile et devriendrait tr\u00e8s fastidieux si nous devions travailler sur un tableau avec 10000 \u00e9l\u00e9ments...</p> <p>Il est alors plus \u00e9l\u00e9gant d'abstraire un peu la m\u00e9thode en \u00e9crivant : T<sub>i</sub> = T<sub>i</sub> + 1  et en faisant varier la valeur de i qui est la seule chose qui change dans les op\u00e9rations \u00e0 r\u00e9aliser.</p> <p>Ce faisant, nous utilisons une boucle sur i, qui est alors appell\u00e9e variable muette.</p> <p>Remarque : nous pouvons appeler cette variable muette j, k, l ou n'importe quoi d'autre; la lettre i est habituellement choisie car, en fait, il s'agit d'un it\u00e9rateur.</p>"},{"location":"3_Algorithmie/#boucles-avec-bornes-et-pas","title":"Boucles avec bornes et pas","text":"<pre><code>Pour i allant de bi \u00e0 bf avec un pas de p\n    bloc d'instructions\nFin pour\n</code></pre> <ul> <li>i est le compteur de la boucle</li> <li>bi la borne initiale</li> <li>bf la borne finale</li> <li>p le pas</li> </ul> <p>Compteur, bornes et pas sont de type entier. Les bornes et le pas peuvent \u00eatre peuvent \u00eatre des identificateurs, des constantes ou encore des expressions.</p> <p>A l'entr\u00e9e dans la boucle, i prend la valeur de la borne initiale bi et \u00e0 chaque passage dans la boucle, le compteur i est incr\u00e9ment\u00e9 de la valeur du pas p. Lorsque i atteint une valeur strictement sup\u00e9rieure \u00e0 la borne finale bf, le programme sort de la boucle.</p> <p>Dans le langage courant, on parle plus volontier de boucle for. Elle est pr\u00e9sent\u00e9e comme la plus simple, car c'est celle dans laquelle sont pr\u00e9cis\u00e9s la totalit\u00e9 des bornes ainsi que le pas d'incr\u00e9ment (le nombre qui s'ajoute \u00e0 la variable muette entre deux \u00e9tapes).</p> <p>Lorsque la pas est \u00e9gal \u00e0 1, ce qui est le plus courant, il n'est pas obligatoire de l'\u00e9crire.</p> <pre><code>Pour i allant de bi \u00e0 bf avec un pas de 1\n</code></pre> <pre><code>Pour i allant de de bi \u00e0 bf\n</code></pre> <p>Si nous retournons \u00e0 notre exemple initial, nous pouvons maintenant simplement \u00e9crire :</p> <pre><code>Pour i allant de de 0 \u00e0 2\n    T[i] = T[i] + 1\nFin pour\n</code></pre> <p>Note : une fois sorti de la boucle, le compteur n'a plus aucune valeur. Il est ainsi possible d'encha\u00eener deux boucles avec un compteur nomm\u00e9, dans les deux cas, i sans que cela pose de probl\u00e8me.</p>"},{"location":"3_Algorithmie/#boucles-tant-que","title":"Boucles tant que","text":"<p>La boucle tant que, ou boucle while, permet d'\u00e9x\u00e9cuter un bloc d'instructions tant qu'une condition est r\u00e9alis\u00e9e. Elle comporte une condition qui est test\u00e9e avant chaque passage dans la boucle (y compris lors du premier passage). <pre><code>Tant que condition\n    bloc d'instructions\nFin tant que\n</code></pre></p> <p>Par exemple :</p> <pre><code>n = 0\nTant que n &lt; 5\n    n = n + 1\nFin tant que\n</code></pre> <p>ajoute 1 \u00e0 la valeur de la variable n \u00e0 chaque passage dans la boucle tant que la valeur de n est inf\u00e9rieur \u00e0 5. Ainsi, \u00e0 la sortie de la boucle, n vaut 5.</p>"},{"location":"3_Algorithmie/#sorties-de-boucle","title":"Sorties de boucle","text":"<p>Pour des raisons de simplification des algorithmes (pour \u00e9viter de parcourir un bloc d'inscruction si cela n'a pas d'int\u00e9r\u00eat dans la r\u00e9solution du probl\u00e8me), il est utile de disposer d'op\u00e9rateurs de d\u00e9branchement qui permettent de passer directement \u00e0 la valeur suivante de l'it\u00e9rateur ou de sortir directement de la boucle en cours.</p> <p>Ces deux fonctionnalit\u00e9 des boucles sont not\u00e9es :</p> <ul> <li>continue, qui permet de passer \u00e0 la valeur suivante;</li> <li>break, qui permet de sortir de la boucle, les expressions conservent leurs valeurs, et on continue l'ex\u00e9cution du programme \u00e0 partir de la premi\u00e8re expression qui suit la fin de boucle courante (c'est \u00e0 dire \u00e0 la suite de l\u2019accolade fermante).</li> </ul>"},{"location":"3_Algorithmie/#boucles-ensembliste","title":"Boucles ensembliste","text":"<p>La boucle ensembliste est utilis\u00e9 pour ext\u00e9cuter un bloc d'instructions sur toutes les entit\u00e9s d'un ensemble d'\u00e9l\u00e9ments.</p> <pre><code>Pour elem dans tabl\n    bloc d'instructions\nFin pour\n</code></pre> <p>Par exemple, si <code>premiers</code> est l'ensemble des nombres premiers inf\u00e9rieurs \u00e0 100, l'algorithme suivant calcule la somme de ses nombres premiers :</p> <pre><code>resultat = 0\nPour nb_premier dans premiers\n    resultat = resultat + nb_premier\nFin pour\n</code></pre> <p>La boucle ensembliste est essentiellement utilis\u00e9e pour la gestion des listes que nous \u00e9tudierons ult\u00e9rieurement.</p>"},{"location":"3_Algorithmie/#equivalences-de-boucles","title":"Equivalences de boucles","text":"<p>Nous remarquerons qu'un algorithme \u00e9crit avec une boucle avec borne et pas pourra \u00e9galement l'\u00eatre avec une boucle tant que.</p> <pre><code>n = 0\nPour i allant de 0 \u00e0 4\n    n = n + i\nFin pour\n</code></pre> <p>Est \u00e9quivalent, avec une boucle tant que \u00e0 :</p> <pre><code>n = 0\ni = 0\nTant que i &lt; 5\n    n = n + i\n    i = i + 1\nFin tant que\n</code></pre> <p>De mani\u00e8re plus g\u00e9n\u00e9rale, il sera souvent possible d'\u00e9crire un algorithme en utilisant l'un ou l'autre des types de boucle. Il arrivera qu'un type de boucle soit plus adapt\u00e9 dans un contexte particulier.</p>"},{"location":"3_Algorithmie/#combinaisons-de-boucles","title":"Combinaisons de boucles","text":"<p>Si les boucles peuvent \u00eatre imbriqu\u00e9es les unes dans les autres ou successives, elles ne peuvent jamais \u00eatre crois\u00e9es.</p> <p>Par exemple, pour calculer la somme des \u00e9l\u00e9ments d'une matrice (not\u00e9e <code>mat</code>, de <code>n</code> lignes et <code>p</code> colonnes, <code>mat[i][j]</code> \u00e9tant l'\u00e9l\u00e9ment \u00e0 la i-\u00e8me ligne et j-i\u00e8me colonne), nous \u00e9crirons l'algorithme suivant :</p> <pre><code>s = 0\nPour i allant de 0 \u00e0 n - 1\n    Pour j allant de 0 \u00e0 p - 1\n        s = s + mat[i][j]\n    Fin pour\nFin pour\n</code></pre>"},{"location":"3_Algorithmie/#les-tests","title":"Les tests","text":"<p>Nous \u00e9tudierons dans ce paragraphe les tests \"simples\" et les tests \u00e0 choix multiples qui sont deux structures alternatives.</p>"},{"location":"3_Algorithmie/#le-test-simple","title":"Le test simple","text":"<p>Imaginons que nous voulions \u00e9crire un programme permettant de d\u00e9terminer si un nombre entier est pair, par exemple pour savoir si une adresse se situe du c\u00f4t\u00e9 gauche ou droit d'une rue. La structure g\u00e9n\u00e9rale du programme serait la suivante :</p> <pre><code>Si le nombre est pair alors\n    adresse c\u00f4t\u00e9 droit\nSinon\n    adresse c\u00f4t\u00e9 gauche\nFin si\n</code></pre> <p>Pr\u00e9cisons que les blocs d'instructions des parties si et sinon peuvent \u00eatre vides (l'un ou l'autre, les deux vides n'ayant aucun int\u00e9r\u00eat).</p> <p>Par exemple, si nous souhaitons d\u00e9terminer le maximum de deux variables A et B pour le mettre dans une variable max, nous pouvons \u00e9crire l'algorithme suivant :</p> <pre><code>Si a &gt; b alors\n    max = a\nSinon\n    max = b\nFin si\n</code></pre>"},{"location":"3_Algorithmie/#le-test-a-choix-multiple","title":"Le test \u00e0 choix multiple","text":"<p>Il est parfois n\u00e9cessaire d'\u00e9valuer plusieurs cas pour d\u00e9terminer l'action \u00e0 effectuer. Immaginons par exemple vouloir \u00e9crire un programme calculant le nombre de jours d'un mois donn\u00e9. La structure g\u00e9n\u00e9rale du programme serait la suivante :</p> <pre><code>Si le num\u00e9ro du mois est 1, 3, 5, 7, 8, 10 ou 12 alors\n    le mois compte 31 jours\nFin si\nSi le num\u00e9ro du mois est 4, 6, 9, 11 alors\n    le mois compte 30 jours\nFin si\nSi le num\u00e9ro du mois est 2 alors\n    Si l'ann\u00e9e est bisextile alors\n        le mois compte 29 jours\n    Sinon\n        le moins compte 28 jours\n    Fin si\nFin si\nSi le num\u00e9ro de mois est sup\u00e9rieur \u00e0 12 alors\n    il y a un probl\u00e8me\nFin si\n</code></pre> <p>Il est tout \u00e0 fait possible d'encha\u00eener les conditions comme nous l'avons fait ci-dessus, mais cela n'est pas tr\u00e8s \u00e9l\u00e9gant. A la place, on pr\u00e9f\u00e9rera utiliser la structure du test \u00e0 choix multiples :</p> <pre><code>Selon le num\u00e9ro du mois\n    cas 1  instruction 1\n    cas 2  instruction 2\n    ....\n    sinon  instuction n\nFin selon\n</code></pre>"},{"location":"3_Algorithmie/#les-fonctions","title":"Les fonctions","text":"<p>Lors de l'\u00e9criture de programmes, nous allons \u00eatre confront\u00e9 \u00e0 une r\u00e9alit\u00e9 : les m\u00eames probl\u00e8mes reviennent avec une r\u00e9currence importante. Aussi afin de ne pas avoir \u00e0 r\u00e9-\u00e9crire les m\u00eames portions de code \u00e0 chaque fois, nous allons utiliser une structure permettant de faire r\u00e9f\u00e9rence facilement \u00e0 tout un ensemble d'instructions : les fonctions.</p> <p>Nous verrons que l'organisation des algorithmes en fonctions facilite \u00e9galement leur compr\u00e9hension : au lieu d'avoir un bloc contenant de nombreuses instructions, nous manipulerons plusieurs blocs d'instructions r\u00e9alisant chacun une tache tr\u00e8s sp\u00e9cifique.</p>"},{"location":"3_Algorithmie/#definition_1","title":"D\u00e9finition","text":"<p>Une fonction est une s\u00e9quence d'instructions, identifi\u00e9e par un nom, et fonctionnnant \u00e0 l'aide param\u00e8tres.</p> <p>Une fonction est compos\u00e9e de deux parties : une en-t\u00eate, d\u00e9finissant le nom et les param\u00e8tres, et un corps, d\u00e9crivant ce qu'effectue l'algorithme.</p> <p><pre><code>Fonction \u01f9om_de_la_fonction (a,  b,  c)\n    bloc d'instructions\nFin fonction\n</code></pre> La syntaxe pour l'appel d'une fonction est la suivante : <pre><code>\u01f9om_de_la_fonction(a, b, c)\n</code></pre></p> <p>Une fonction peut \u00e9ventuellement retourner une valeur. On utilisera alors l'instruction <code>Retourner</code> :</p> <p><pre><code>Fonction plus_un (a)\n    Retourner a + 1\nFin fonction\n</code></pre> Pour l'appel d'une fonction retournant une valeur et l'affectation de cette valeur, on \u00e9crira : <pre><code>a_plus_un = plus_un(a)\n</code></pre> L'instruction <code>Retourner</code> correspond \u00e0 la fin de la fonction. Toutes les instructions situ\u00e9es dans la fonction mais apr\u00e8s l'instruction <code>Retourner</code> ne seront pas execut\u00e9es.</p> <p>Remarque : on pourra parler de proc\u00e9dure pour une fonction ne retournant aucune valeur, et de fonction (tout court) pour celles retournant une valeur.</p>"},{"location":"3_Algorithmie/#recursivite","title":"R\u00e9cursivit\u00e9","text":"<p>Un algorithme est dit r\u00e9cursif s'il est d\u00e9fini \u00e0 partir de lui m\u00eame.</p> <p>On prendra pour exemple la fonction qui calcule la somme des n premiers entiers. En mode it\u00e9ratif, elle s'\u00e9crit :</p> <pre><code>Fonction somme(n)\n  res = 0\n  Pour i allant de 0 \u00e0 n\n    res = res + i\n  Fin pour\n  Retourner res\nFin fonction\n</code></pre> <p>En mode r\u00e9cursif, on l'\u00e9crira :</p> <pre><code>Fonction somme_recursive(n)\n  Si n = 0\n    Retourner 0\n  Sinon\n    res = n + somme_recursive(n-1)\n    Retourner res\n  Fin si\nFin fonction\n</code></pre> <p>Pour bien se convaincre que \u00e7a marche (car le fonctionnement est contre-intuitif), on peut d\u00e9rouler les \u00e9tapes r\u00e9alis\u00e9es par la fonction.</p> <p>En faisant cela, on remarque que la condition d'arr\u00eat des appels r\u00e9cursifs est primordiale, car sinon la fonction s'ex\u00e9cuterait \u00e0 l'infini.</p> <p>La r\u00e9cursivit\u00e9 est similaire aux d\u00e9monstrations par r\u00e9currence : la condition d'arr\u00eat correspond au cas trivial (initiation), et la partie recursive \u00e0 l'h\u00e9r\u00e9dit\u00e9.</p>"},{"location":"4.c_exercices_python/","title":"Exercices de Python","text":""},{"location":"4.c_exercices_python/#exercices-de-mise-en-pratique-de-python","title":"Exercices de mise en pratique de Python","text":""},{"location":"4.c_exercices_python/#tp-distance-entre-points","title":"TP \u2014 Distance entre points","text":"<p>Dans ce TP, nous cherchons \u00e0 \u00e9valuer la dispersion de points tir\u00e9s al\u00e9atoirement dans un carr\u00e9 de c\u00f4t\u00e9 1. Nous nous int\u00e9resserons aux distances minimale, maximale et moyenne entre les points, ainsi qu\u2019\u00e0 la position du centre de gravit\u00e9 du semis de points.</p> <p>Tout au long du TP, un point sera repr\u00e9sent\u00e9 par un couple de coordonn\u00e9es <code>(x, y)</code>.</p>"},{"location":"4.c_exercices_python/#etapes-du-tp","title":"\u00c9tapes du TP","text":"<ul> <li> <p>\u00c9crire une fonction de tirage al\u00e9atoire d\u2019un point dans une emprise d\u00e9finie par les coordonn\u00e9es <code>((xmin, ymin), (xmax, ymax))</code></p> </li> <li> <p>\u00c9crire une fonction de tirage de <code>n</code> points al\u00e9atoires dans cette emprise :</p> </li> <li> <p>Modifier votre fonction pr\u00e9c\u00e9dente pour que, si les coordonn\u00e9es de l\u2019emprise ne sont pas pr\u00e9cis\u00e9es, elles soient par d\u00e9faut <code>((0, 0), (1, 1))</code></p> </li> <li> <p>Compl\u00e9ter votre programme avec une fonction calculant le centre de gravit\u00e9 d\u2019un ensemble de points (c\u2019est-\u00e0-dire la position moyenne des points).</p> </li> <li> <p>Ajouter une fonction calculant les :</p> </li> <li>distances minimale et maximale entre deux points de l\u2019ensemble</li> <li> <p>distance moyenne entre tous les points</p> </li> <li> <p>Observer comment \u00e9voluent ces valeurs lorsque le nombre de points du semis augmente.</p> </li> </ul>"},{"location":"4.c_exercices_python/#tp-generalisation-cartographique","title":"TP \u2014 G\u00e9n\u00e9ralisation cartographique","text":""},{"location":"4.c_exercices_python/#algorithme-de-douglas-peucker","title":"Algorithme de Douglas-Peucker","text":"<p>L\u2019algorithme de Douglas-Peucker est utilis\u00e9 pour simplifier une polyligne, en supprimant des points non significatifs de la forme globale de la g\u00e9om\u00e9trie.</p> <p>La simplification propos\u00e9e consiste \u00e0 remplacer une polyligne de plusieurs points par une ligne \u00e0 deux points si la distance du point le plus \u00e9loign\u00e9 de la droite form\u00e9e par les extr\u00e9mit\u00e9s de la polyligne est inf\u00e9rieure \u00e0 un seuil.</p> <p></p> <p>Figure 1 \u2013 Principe de simplification d\u2019une polyligne</p> <p>Le principe de l\u2019algorithme est le suivant :</p> <ul> <li>\u00c0 l\u2019\u00e9tape initiale, les extr\u00e9mit\u00e9s de la polyligne sont s\u00e9lectionn\u00e9es.</li> <li>Pour chacun des points entre ces deux extr\u00e9mit\u00e9s, on calcule alors la distance du point \u00e0 la droite liant les extr\u00e9mit\u00e9s.</li> </ul> <p>La suite du traitement d\u00e9pend de la valeur de la distance maximale ainsi calcul\u00e9e :</p> <ol> <li>S\u2019il n\u2019y a aucun point, l\u2019algorithme se termine (la ligne n\u2019est pas simplifiable) ;</li> <li>Si la distance maximale est inf\u00e9rieure \u00e0 un seuil donn\u00e9, on supprime tous les points (ils sont non significatifs) ;</li> <li>Si la distance maximale est sup\u00e9rieure au seuil, la ligne n\u2019est pas simplifiable :</li> <li>on divise la polyligne en deux parties allant :<ul> <li>de la premi\u00e8re extr\u00e9mit\u00e9 au point interm\u00e9diaire le plus distant</li> <li>du point interm\u00e9diaire le plus distant \u00e0 la deuxi\u00e8me extr\u00e9mit\u00e9</li> </ul> </li> <li>on r\u00e9p\u00e8te l\u2019op\u00e9ration sur les deux parties.</li> </ol> <p></p> <p>Figure 2 \u2013 Principe de l\u2019algorithme de Douglas-Peucker \u2014 source Wikipedia</p> <p>Dans tout ce qui suit :</p> <ul> <li>un point est repr\u00e9sent\u00e9 par un couple de coordonn\u00e9es <code>(x, y)</code></li> <li>une droite ou un segment est repr\u00e9sent\u00e9 par un couple de couples de coordonn\u00e9es :   <code>((x_a, y_a), (x_b, y_b))</code></li> </ul> <p>Nous commencerons par \u00e9crire des fonctions g\u00e9n\u00e9rales qui seront utiles pour l\u2019impl\u00e9mentation de l\u2019algorithme \u00e0 la question suivante.</p>"},{"location":"4.c_exercices_python/#etapes-du-tp_1","title":"\u00c9tapes du TP","text":"<ul> <li>\u00c9crire une fonction calculant la pente d\u2019une droite</li> <li> <p>\u00c9crire une fonction calculant l\u2019ordonn\u00e9e \u00e0 l\u2019origine d\u2019une droite   (elle prend en param\u00e8tre les coordonn\u00e9es d\u2019un point A de la droite ainsi que sa pente)</p> </li> <li> <p>Ajouter une fonction <code>distance(point, droite)</code>   Cette fonction calcule la distance d\u2019un point A \u00e0 une droite.   Elle devra g\u00e9rer les cas particuliers des droites verticales ou horizontales.</p> </li> </ul> <p>Dans le cas g\u00e9n\u00e9ral, pour une droite d\u2019\u00e9quation : <code>y = p * x + m</code> la distance d\u2019un point <code>A(xA, yA)</code> \u00e0 cette droite est donn\u00e9e par la formule :</p> <p></p> <ul> <li> <p>\u00c9crire une fonction <code>douglas_peuker(points, e)</code>   Cette fonction simplifie une liste de points selon la m\u00e9thode de Douglas-Peucker, avec un seuil <code>e</code></p> </li> <li> <p>Tester diff\u00e9rents seuils sur la liste de points suivante : <code>(0,0), (1,0), (10,1), (11,1), (15,2), (17,1), (20,1), (27,0), (28,4), (30,6), (33,8), (34,0)</code></p> </li> </ul>"},{"location":"4.c_exercices_python/#gestion-dassociation","title":"Gestion d'association","text":"<p>TP_association.pdf</p>"},{"location":"4_intro_python/","title":"Introduction \u00e0 Python","text":""},{"location":"4_intro_python/#programmation-avec-python","title":"Programmation avec Python","text":""},{"location":"4_intro_python/#introduction","title":"Introduction","text":"<p>Ce cours est une initiation au langage de programmation Python. Il n'est pas n\u00e9cessaire de d\u00e9j\u00e0 conna\u00eetre ce langage, ni d'avoir des notions avanc\u00e9es en programmation, pour pouvoir l'aborder. Dans la mesure du possible, chaque notion est illustr\u00e9e d'exemple. Le cours se concentre sur la description du fonctionnement du langage et des syntaxes employ\u00e9es.</p> <p>On utilisera l'IDE Visual Studio Code (lien), qui permet d'\u00e9crire du code pour Python mais aussi bien d'autres langages (web, etc). On installera Python et l'extension Python pour VS Code en suivant le tutotriel suivant : https://code.visualstudio.com/docs/languages/python.</p> <p>La version 3 de Python est la seule utilis\u00e9e tout au long du cours. On privil\u00e9giera la derni\u00e8re version (3.13 au moment de l'\u00e9criture de ce texte).</p>"},{"location":"4_intro_python/#types-et-operations","title":"Types et op\u00e9rations","text":"<p>Ce chapitre va nous permettre de commencer \u00e0 utiliser le langage Python. Nous nous limiterons pour commencer \u00e0 des op\u00e9rations basiques comme des op\u00e9rations math\u00e9matiques ou des manipulations de cha\u00eenes de caract\u00e8res. Plus pr\u00e9cis\u00e9ment, nous nous limiterons dans ce chapitre aux op\u00e9rations sur des types de base d\u00e9finis dans le langage.</p> <p>Avant cela, nous d\u00e9finirons ce que sont une variable et un type en informatique. Nous introduirons un concept important en Python, le typage dynamique, et montrerons comment sont g\u00e9r\u00e9es donn\u00e9es dans ce langage.</p>"},{"location":"4_intro_python/#variables-et-types-en-python","title":"Variables et types en Python","text":""},{"location":"4_intro_python/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>La programmation consiste essentiellement \u00e0 manipuler des donn\u00e9es. Ces donn\u00e9es de natures diverses sont stock\u00e9es sous forme binaire dans la m\u00e9moire de l'ordinateur. Pour y acc\u00e9der, un programme d\u00e9finit des variables.</p> <p>Nous d\u00e9finirons ainsi une variable comme l'association d'un nom et d'une valeur. Le nom est utile au programmeur pour savoir quelle donn\u00e9e il manipule, tandis que l'ordinateur utilise la valeur associ\u00e9e. De mani\u00e8re imag\u00e9e, le nom peut \u00eatre vu comme une simple \u00e9tiquette sur une donn\u00e9e.</p> <p>En Python, le nom (on parle parfois d'identificateur) :   + ne peut contenir que des lettres, des chiffres et des blancs soulign\u00e9s;   + ne peut pas contenir d'espace ou de caract\u00e8res sp\u00e9ciaux (&amp;, ;...);   + ne peut pas commencer par un chiffre;   + distingue minuscules et majuscules (on dit que le langage est sensible \u00e0 la casse);   + doit \u00eatre unique. Par convention, pour les noms de variable, on s\u00e9parera les mots par des blancs soulign\u00e9s : mon_nom_de_variable. Les noms de variable commen\u00e7ant par deux _ et se terminant par deux _ sont r\u00e9serv\u00e9s au langage (exemple : str). Certains mots-cl\u00e9 sont \u00e9galement r\u00e9serv\u00e9s par le langage. Il n'est pas possible de cr\u00e9er une variable portant l'un de ces noms : <code>and else in return as except is true assert false lambda try break finally none while class for nonlocal with continue from not yield def global or del if pass elif import raise</code> (liste exhaustive sur la documentation officielle)</p> <p>En Python, la valeur d'une variable est une r\u00e9f\u00e9rence vers une adresse m\u00e9moire (un emplacement pr\u00e9cis dans la m\u00e9moire vive de l'ordinateur). Le contenu de la variable est stock\u00e9 \u00e0 cette adresse m\u00e9moire sous forme d'une suite de nombres binaires. Pour distinguer les diff\u00e9rents contenus, les langages de programmation utilisent des types de variable qui permettent de sp\u00e9cifier le contenu attendu.</p> <p>Contrairement \u00e0 d'autres langages, il n'est pas n\u00e9cessaire de d\u00e9clarer le type d'une variable avant de pouvoir l'utiliser. Plus pr\u00e9cis\u00e9ment, l'interpr\u00e9teur Python d\u00e9tecte lui-m\u00eame le type de l'objet en r\u00e9f\u00e9rence lorsque la variable est utilis\u00e9e dans une expression.</p> <p>Par exemple, lorsque l'on \u00e9crit <code>x = 3</code>, on cr\u00e9e une variable <code>x</code> \u00e0 laquelle on associe l'objet 3 qui est stock\u00e9 dans la m\u00e9moire de l'ordinateur. L'interpr\u00e9teur Python d\u00e9tecte que 3 est un nombre entier et associe donc ce type \u00e0 la variable <code>x</code>.</p> <p>\u00c0 retenir :  + une variable est cr\u00e9\u00e9e lorsqu'on lui affecte pour la premi\u00e8re fois une valeur;  + une variable n'est jamais associ\u00e9e \u00e0 un type en Python. C'est l'objet qu'elle r\u00e9f\u00e9rence qui porte le type;  + une variable est automatiquement remplac\u00e9e par l'objet qu'elle r\u00e9f\u00e9rence dans une expression.</p>"},{"location":"4_intro_python/#types-de-base","title":"Types de base","text":"<p>Python met \u00e0 disposition du programmeur un certain nombre de types ou structures de donn\u00e9es. On parle de types int\u00e9gr\u00e9s (builtins). Il est \u00e9galement possible de d\u00e9finir ses propres structures de donn\u00e9es.</p> <p>Quel est donc l'int\u00e9r\u00eat d'utiliser les structures de donn\u00e9es int\u00e9gr\u00e9s au langage ? Tout d'abord, nous remarquerons que ces types de base sont des composants naturels des structures manipul\u00e9es dans les programmes (on manipule naturellement des entiers, des cha\u00eenes de caract\u00e8res). Cela facilite donc grandement la programmation : il n'y a pas besoin de tout red\u00e9finir pour chaque nouveau programme. Enfin, ces structures de donn\u00e9es sont plus effcaces que des structures de donn\u00e9es que l'on aurait reconstruites (les algorithmes ont \u00e9t\u00e9 optimis\u00e9s, \u00e9crit dans des langages performants comme le C).</p> <p>| Type | Exemples de valeur | | Nombre | 3, 1.1456, -3.5 | | Cha\u00eene de caract\u00e8res | 'mot', 'petit texte' | | Liste | [1, 2, 3], ['a', 'b'], ['a', 5, 2.3, 'f'] | | Tuple | (1, 3), ('a', 'b', 'c') | | Ensemble | set('abc'), 'a', 'b', 'c' | | Dictionnaire | 1 :'a', 2 :'b'  | | Fichier | open('fichier.txt') | | Bool\u00e9en | True, False | | Rien | None |</p>"},{"location":"4_intro_python/#les-types-numeriques","title":"Les types num\u00e9riques","text":"<p>Les nombres sont des objets relativement basiques et dont l'utilisation est assez naturelle. Python inclus les types num\u00e9riques \"classiques\", que l'on retrouve dans la plupart des langages de programmation : nombres entier, nombres \u00e0 virgule; mais \u00e9galement d'autres moins courants : nombres complexes, nombres rationnels. Ces types couvrent la plupart des besoins standards.</p> <p>| Type | Exemple de valeur | | Integer | 2, -3, 156235789 | | Float | 2.3, -4.12, 1.0, 189489.23891 | | Complex | 2 + 3j | | Decimal | Decimal('0.1') | | Fraction | Fraction(1, 3) |</p> <p>Les nombres Python supportent les op\u00e9rations math\u00e9matiques classiques list\u00e9es dans la table c-dessous. Dans le cas d'expression avec des parenth\u00e8ses, Python applique la r\u00e8gle math\u00e9matique classique et calcule en premier les sous-expressions entre parenth\u00e8ses.</p> <p>| Op\u00e9rateur | Signification | | + | Addition | | - | Soustraction | | * | Multiplication | | ** | Puissance | | / | Division | | // | Division enti\u00e8re | | % | Reste d'une division enti\u00e8re (modulo) |</p> <p>On pourra convertir un nombre quelconque en nombre entier via la fonction <code>int()</code> ou en nombre r\u00e9el via la fonction <code>float()</code></p>"},{"location":"4_intro_python/#les-booleens","title":"Les bool\u00e9ens","text":"<p>Une variable de type bool\u00e9en ne pourra prendre que deux valeurs : <code>True</code> (vrai) et <code>False</code> (faux).</p> <p>Les op\u00e9rations logiques retournent des bool\u00e9ens. La table suivante liste les op\u00e9rateurs de comparaison. Ces op\u00e9rateurs s'appliquent \u00e0 tous les types de donn\u00e9es, \u00e0 condition que les types soient comparables (comparer 5 \u00e0 \"toto\" n'a pas vraiment de sens).</p> <p>| Op\u00e9rateur | Signification | | &gt; | Sup\u00e9rieur | | &lt; | Inf\u00e9rieur | | &gt;= | Sup\u00e9rieur ou \u00e9gal | | &lt;= | Inf\u00e9rieur ou \u00e9gal | | == | Egal | | != ou &lt;&gt; | Diff\u00e9rent de | | is | Objet identique | | is not | Objet diff\u00e9rent |</p> <p>Dans l'exemple ci-dessous, nous affectons \u00e0 <code>x</code> le r\u00e9sultat de la comparaison <code>3 != 5</code>. Ce r\u00e9sultat est un bool\u00e9en : <pre><code>&gt;&gt;&gt; x = (3 != 5)\n&gt;&gt;&gt; x\nTrue\n</code></pre></p> <p>Le bool\u00e9ens peuvent \u00eatre combin\u00e9es entre eux \u00e0 l'aide des mots cl\u00e9 <code>and</code>, <code>or</code> et <code>not</code>.</p> <p>Mini-exo : table de v\u00e9rit\u00e9</p>"},{"location":"4_intro_python/#le-type-rien","title":"Le type 'rien'","text":"<p>Python propose un type sp\u00e9cial qui ne peut prendre qu'une seule valeur possible, <code>None</code>, et qui est utilis\u00e9 pour signifier qu'une variable ne contient rien. Ou plus exactement, elle r\u00e9f\u00e9rence un objet et cet objet est l'objet \"rien\".</p> <p>Il s'agit d'une valeur qui est utilis\u00e9e par d\u00e9faut lorsqu'une op\u00e9ration n'a pas de retour explicite ou n'a pas pu \u00eatre men\u00e9e \u00e0 son terme. Le type \"rien\" est ainsi utilis\u00e9 pour v\u00e9rifier que des parties de programme ont correctement fonctionn\u00e9.</p>"},{"location":"4_intro_python/#les-chaines-de-caracteres","title":"Les cha\u00eenes de caract\u00e8res","text":""},{"location":"4_intro_python/#creation-dune-chaine-de-caracteres","title":"Cr\u00e9ation d'une cha\u00eene de caract\u00e8res","text":"<p>Les apostrophes et guillemets s'utilisent indiff\u00e9remment pour d\u00e9finir une cha\u00eene de caract\u00e8res <code>\"...\"</code> ou <code>'...'</code>.</p> <p>L'int\u00e9r\u00eat d'utiliser l'une ou l'autre des deux formes est de pouvoir int\u00e9grer des apostrophes ou guillemets dans une cha\u00eene : <pre><code>\"aujourd'hui\", 'le type \"rien\"'\n</code></pre></p> <p>Le caract\u00e8re d'\u00e9chappement dans une cha\u00eene de caract\u00e8res est le backslash <code>\\</code>. <pre><code>'aujourd\\'hui'\n</code></pre></p> <p>Python propose un troisi\u00e8me mode de d\u00e9finition de cha\u00eenes de caract\u00e8res qui commence et se termine par trois guillemets : <code>\"\"\"...\"\"\"</code>. Cette syntaxe permet de conserver la mise en forme d'un bloc de texte. <pre><code> \"\"\"Les trois quotes : permettant d'enregistrer la mise en forme.\n\n=&gt; y compris les sauts de ligne\n, les tabulations...\"\"\"\n</code></pre></p>"},{"location":"4_intro_python/#manipulation-de-chaines-de-caracteres","title":"Manipulation de cha\u00eenes de caract\u00e8res","text":"<p>Les op\u00e9rateurs suivants sont applicables aux cha\u00eenes de caract\u00e8res.</p> <p>| Op\u00e9rateur | Signification | | + | Concat\u00e9nation de cha\u00eenes de caract\u00e8res | | * | R\u00e9p\u00e9tition d'une cha\u00eene de caract\u00e8res | | <code>in</code> | Inclusion d'une cha\u00eene dans une autre | | <code>not in</code> | Non inclusion d'une cha\u00eene dans une autre | | <code>[i]</code> | Caract\u00e8re \u00e0 la i-i\u00e8me position dans la cha\u00eene | | <code>[i:j]</code> | Caract\u00e8res compris entre les i-i\u00e8me et j-i\u00e8me positions |</p> <p>De plus, on peut appliquer de nombreuses fonctions aux cha\u00eenes de caract\u00e8res, qui sont d\u00e9crites dans la documentation officielle</p>"},{"location":"4_intro_python/#les-listes","title":"Les listes","text":"<p>Une liste est un tableau d'objets qui peuvent \u00eatre de n'importe quel type. Il est possible de modifier, ajouter ou supprimer des \u00e9l\u00e9ments d'une liste sans avoir \u00e0 la red\u00e9finir.</p> <p>Une liste est d\u00e9finie par un ensemble de valeurs entre deux crochets : <pre><code>&gt;&gt;&gt; a = [2016, \"ENSG\", 'G\u00e9omatique']\n&gt;&gt;&gt; type(a)\n&lt;class 'list'&gt;\n&gt;&gt;&gt; a\n[2016, 'ENSG', 'G\u00e9omatique']\n</code></pre></p> <p>Les listes peuvent \u00e9galement \u00eatre imbriqu\u00e9es : <pre><code>&gt;&gt;&gt; b = [a, [1, 2, 3, 4]]\n&gt;&gt;&gt; b\n[[2016, 'ENSG', 'G\u00e9omatique'], [1, 2, 3, 4]]\n</code></pre></p> <p>Pour cr\u00e9er une liste vide, nous utilisons des crochets sans rien \u00e0 l'int\u00e9rieur : <pre><code>&gt;&gt;&gt; c = []\n&gt;&gt;&gt; type(c)\n&lt;class 'list'&gt;\n</code></pre></p> <p>Les listes supportent les op\u00e9rateurs suivants :</p> <p>| Op\u00e9rateur | Signification | | x in s | x est dans s | | x not in s | x n'est pas dans s | | s + t | concat\u00e9nation de s et t | | s * n | ajouter n fois s \u00e0 lui-m\u00eame | | s[i] | \u00e9l\u00e9ment \u00e0 la i-\u00e8me position | | s[i:j] | sous-liste de s, de la i-\u00e8me \u00e0 la (j-1)-\u00e8me position | | s[i:j:k] | sous-liste de s, de la i-\u00e8me \u00e0 la (j-1)-\u00e8me position avec un pas de k | | len(s) | nombre d'\u00e9l\u00e9ments de la liste s | | min(s) | plus petit \u00e9l\u00e9ment de la liste s (lorsque cela \u00e0 un sens) | | max(s) | plus grand \u00e9l\u00e9ment de la liste s (lorsque cela \u00e0 un sens) | | sum(s) | somme des \u00e9l\u00e9ments de la liste s (lorsque cela \u00e0 un sens) | | s.index(x, i, j) | index de la premi\u00e8re occurence de x dans s, \u00e0 partir de l'indice i et jusqu'\u00e0 j | | s.count(x) | nombre d'occurence de x dans s | | L[i] = x | El\u00e9ment \u00e0 la position i remplac\u00e9 par x | | L[i:j] = t | Partie entre les position i et j remplac\u00e9 par la liste t | | del(L[i:j]) | Suppression des \u00e9l\u00e9ments entre les positions i et j. Equivalent \u00e0 L[i:j] = [] | | L[i:j:k] = t | Partie entre les position i et j avec un pas de k remplac\u00e9 par la liste t | | del(L[i:j:k]) | Suppression des \u00e9l\u00e9ments entre les positions i et j avec un pas de k. Equivalent \u00e0 L[i:j:k] = [] | | L += t | Ajoute t \u00e0 L | | L *= n | Ajoute n-1 fois L \u00e0 elle-m\u00eame |</p> <p>De plus, les listes impl\u00e9mentent un certain nombre de de fonctions, en voici quelques-unes : + <code>l.append(x)</code> : Ajoute l'\u00e9l\u00e9ment x \u00e0 la fin de la liste l + <code>l.reverse()</code> : Inverse l'ordre des \u00e9l\u00e9ments de la liste + <code>l.pop(i)</code> : Retourne et supprime de la liste l'\u00e9l\u00e9ment \u00e0 la position i + <code>l.insert(i, x)</code> : Insertion de l'\u00e9l\u00e9ment x \u00e0 la position i</p> <p>D'autre fonctions existent, \u00e0 l'aide d'un IDE une liste est disponible.</p>"},{"location":"4_intro_python/#les-dictionnaires","title":"Les dictionnaires","text":"<p>Les dictionnaires sont des objets semblables aux listes mais plus souples en ce qui concerne le r\u00e9f\u00e9rencement des valeurs. Alors qu'une liste r\u00e9f\u00e9rence les \u00e9l\u00e9ments qu'elle contient \u00e0 l'aide de leur position (un entier compris entre 0 et la taille de la liste), un dictionnaire se contente d'associer l'\u00e9l\u00e9ment \u00e0 un autre \u00e9l\u00e9ment de type immuable (entier, r\u00e9el, cha\u00eene, tuple). On dit que le dictionnaire associe une valeur \u00e0 une cl\u00e9.</p> <p>Les \u00e9l\u00e9ments d'un dictionnaire ne sont pas ordonn\u00e9s (il n'est pas possible de les trier) et on y acc\u00e8de uniquement par leurs cl\u00e9s. La structure d'un dictionnaire n'est pas fig\u00e9e, on peut ajouter/modifier/supprimer des \u00e9l\u00e9ments sans avoir besoin de recr\u00e9er le dictionnaire : le dictionnaire est modifiable.</p> <p>La syntaxe de cr\u00e9ation d'un dictionnaire est la suivante : <pre><code>&gt;&gt;&gt; dico = {cle1: valeur1 , cle2: valeur2...}\n</code></pre></p> <p>On peut cr\u00e9er un dictionnaire vide : <pre><code>&gt;&gt;&gt; dico = {} &gt;&gt;&gt; dico = dict()\n</code></pre></p> <p>Pour acc\u00e9der \u00e0 la valeur d'un \u00e9l\u00e9ment, la syntaxe est semblable \u00e0 celle d'une liste, mais l'indice n'est plus uniquement un entier : <code>dico[cle]</code> retourne la valeur associ\u00e9 \u00e0 la cl\u00e9. <pre><code>&gt;&gt;&gt; dico = {'prenom': 'paul', 'age': 24} &gt;&gt;&gt; dico['prenom'] 'paul'\n</code></pre></p> <p>L'ajout d'une nouvel \u00e9l\u00e9ment est assez ais\u00e9 : <pre><code>&gt;&gt;&gt; dico[0] = 'rouge' &gt;&gt;&gt; dico {0: 'rouge', 'age': 24, 'prenom': 'paul'}\n</code></pre></p> <p>Les dictionnaires impl\u00e9mentent aussi un certain nombre de fonctions, dont en voici quelques unes : + <code>d.items()</code> : retourne une s\u00e9quence des couples (cl\u00e9, valeur) du dictionnaire + <code>d.keys()</code> : retourne une s\u00e9quence des cl\u00e9s du dictionnaire + <code>d.values()</code> : retourne une s\u00e9quence des valeurs du dictionnaire</p>"},{"location":"4_intro_python/#les-fichiers","title":"Les fichiers","text":"<p>Dans ce paragraphe, nous nous attarderons sur le dernier type de base qui sera pr\u00e9sent\u00e9 dans ce cours : les fichiers. Nous montrerons comment lire ou \u00e9crire dans un fichier.</p>"},{"location":"4_intro_python/#chemin-dacces-aux-fichiers","title":"Chemin d'acc\u00e8s aux fichiers","text":"<p>Avant de commencer \u00e0 manipuler les fichiers, pr\u00e9cisons qu'il existe deux possibilit\u00e9s pour parcourir l'arborescence d'un syst\u00e8me : utiliser des chemins absolus ou relatifs. Lorsque l'on utilise des chemins absolus, on d\u00e9crit le fichier en partant de la racine du disque. Les chemins prennent la forme : <code>/home/user/cours-python/toto.txt</code>.</p> <p>Avec les chemins relatifs, on tient compte du r\u00e9pertoire courant, c'est \u00e0 dire celui depuis lequel l'interpr\u00e9teur Python est ex\u00e9cut\u00e9 (si l'on ex\u00e9cute un fichier .py directement, le r\u00e9pertoire courant est celui contenant le programme; si on utilise l'interpr\u00e9teur Python, le r\u00e9pertoire courant est celui contenant l'interpr\u00e9teur). Ainsi, si on est dans le r\u00e9pertoire <code>/home/user/cours-python/</code> , on appellera la fichier <code>resultat.txt</code> de ce r\u00e9pertoire en saisissant tout simplement <code>resultat.txt</code>.</p>"},{"location":"4_intro_python/#ouverture-dun-fichier","title":"Ouverture d'un fichier","text":"<p>Pour ouvrir un fichier, on utilise la fonction open(). Elle prend en param\u00e8tre : + le chemin du fichier; + le mode d'ouverture :   - 'r' pour lire uniquement;   - 'w' pour \u00e9crire uniquement (le contenu pr\u00e9c\u00e9dent est \u00e9cras\u00e9);   - 'a' pour \u00e9crire \u00e0 la finn uniquement (le contenu pr\u00e9c\u00e9dent est conserv\u00e9);  Il est possible de combiner les modes pour, par exemple, lire et ajouter \u00e0 la fin (en \u00e9crivant <code>ra</code>).</p> <p>Lorsque le fichier n'est plus utilis\u00e9 par le programme, il est n\u00e9cessaire de le fermer, sans quoi un verrou persiste emp\u00eachant son utilisation par une autre personne/un autre programme. On utilise la fonction close().</p>"},{"location":"4_intro_python/#lecture-dun-fichier","title":"Lecture d'un fichier","text":"<p>Plusieurs modes de lecture d'un fichier sont possible. Les plus courants sont : + la lecture en entier avec la fonction read() + la lecture ligne par ligne avec la fonction readline()</p> <p>Un exemple de lecture : <pre><code>fichier = open(\"fichier.txt\", 'r')\ncontenu = fichier.read()\nfichier.close()\n</code></pre></p>"},{"location":"4_intro_python/#ecriture-dans-un-fichier","title":"Ecriture dans un fichier","text":"<p>Pour \u00e9crire dans un fichier, on utilise la m\u00e9thode write(texte) en lui passant en param\u00e8tre la cha\u00eene de caract\u00e8res \u00e0 \u00e9crire. Elle renvoie le nombre de caract\u00e8res qui ont \u00e9t\u00e9 \u00e9crits. Cette fonction peut \u00eatre appel\u00e9e plusieurs fois pour \u00e9crire plusieurs cha\u00eenes. Elle fonctionne que le fichier soit ouvert en mode 'w' ou 'a'.</p> <pre><code>fichier = open(\"fichier.txt\", 'w')\nfichier.write(\"J'\u00e9cris pour la premi\u00e8re fois dans un fichier texte via Python\")\nfichier.close()\n</code></pre>"},{"location":"4_intro_python/#louverture-avec-with","title":"L'ouverture avec <code>with</code>","text":"<p>L'ouverture et la manipulation de fichiers est une op\u00e9ration source d'erreurs en programmation. De plus, il est facile d'oublier de refermer un fichier apr\u00e8s son utilisation, ce qui peut \u00eatre probl\u00e9matique \u00e9galement.</p> <p>Pour simplifier l'utilisation des fichiers, Python permet d'utiliser un mot cl\u00e9 : <code>with</code>. Avec cette forme d'ouverture d'un fichier, la fermeture du fichier est automatique : <pre><code>with open(\"fichier.txt\", 'r') as fichier:\n  contenu = fichier.read()\n</code></pre></p>"},{"location":"4_intro_python/#syntaxe-du-langage","title":"Syntaxe du langage","text":"<p>Au chapitre pr\u00e9c\u00e9dent, nous avons \u00e9tudi\u00e9 les structures de base int\u00e9gr\u00e9es dans le langage Python. Maintenant que nous ma\u00eetrisons les diff\u00e9rents types de donn\u00e9es, nous pouvons commencer \u00e0 construire nos premi\u00e8res expressions en Python.</p> <p>Dans ce chapitre, nous allons commencer par rappeler les r\u00e8gles g\u00e9n\u00e9rales de construction des expressions en Python, puis nous apprendrons \u00e0 construire les structures \u00e9l\u00e9mentaires du langage.</p>"},{"location":"4_intro_python/#structure-du-code-en-python","title":"Structure du code en Python","text":"<p>En Python, la r\u00e8gle g\u00e9n\u00e9rale est que la fin d\u2019une ligne correspond \u00e0 la fin d\u2019une instruction. Il n\u2019y a pas de symbole de fin d\u2019instruction comme dans d\u2019autres langages.</p> <p>Exemple en Java :</p> <pre><code>instruction1 ;\ninstruction2 ;\n</code></pre> <p>En Python :</p> <pre><code>instruction1\ninstruction2\n</code></pre> <p>Pour d\u00e9finir un bloc de code, Python utilise l\u2019indentation. De plus la ligne d\u2019en-t\u00eate du bloc se termine par <code>:</code> :</p> <pre><code>ligne_d_en_tete:\n    bloc_d_instructions\n</code></pre> <p>Par exemple, un test en Java :</p> <pre><code>if (condition) {\n    instruction1;\n    instruction2;\n}\n</code></pre> <p>devient en Python :</p> <pre><code>if condition:\n    instruction1\n    instruction2\n</code></pre> <p>Les espaces et sauts de ligne sont ignor\u00e9s par l\u2019interpr\u00e9teur. Le code :</p> <pre><code>ligne_d_en_tete:\n\n    instruction1\n\n    instruction2\n</code></pre> <p>est \u00e9quivalent \u00e0 :</p> <pre><code>ligne_d_en_tete:\n    instruction1\n    instruction2\n</code></pre>"},{"location":"4_intro_python/#commentaires","title":"Commentaires","text":"<ul> <li>Commentaire simple : commence par <code>#</code></li> <li>Docstrings : d\u00e9limit\u00e9es par <code>\"\"\"</code></li> </ul>"},{"location":"4_intro_python/#les-affectations","title":"Les affectations","text":"<p>Pour affecter une valeur \u00e0 une variable :</p> <pre><code>a = 3\n</code></pre> <p>Affectations multiples :</p> <pre><code>a, b = 3, 2\na = b = c = 3\n</code></pre>"},{"location":"4_intro_python/#affectations-augmentees","title":"Affectations augment\u00e9es","text":"<pre><code>a = 3\na += 3  # \u00e9quivalent \u00e0 a = a + 3\n</code></pre> <p>Op\u00e9rateurs disponibles : <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, etc.</p>"},{"location":"4_intro_python/#les-tests","title":"Les tests","text":"<pre><code>if condition:\n    instruction1\n    instruction2\n</code></pre>"},{"location":"4_intro_python/#avec-else","title":"Avec <code>else</code>","text":"<pre><code>if x &gt;= 0:\n    print(\"x positif\")\nelse:\n    print(\"x n\u00e9gatif\")\n</code></pre>"},{"location":"4_intro_python/#avec-elif","title":"Avec <code>elif</code>","text":"<pre><code>if x &gt; 0:\n    print(\"x positif\")\nelif x &lt; 0:\n    print(\"x n\u00e9gatif\")\nelse:\n    print(\"x est nul\")\n</code></pre>"},{"location":"4_intro_python/#les-boucles","title":"Les boucles","text":""},{"location":"4_intro_python/#boucle-while","title":"Boucle <code>while</code>","text":"<pre><code>i = 0\nwhile i &lt; 3:\n    print(i)\n    i += 1\n</code></pre>"},{"location":"4_intro_python/#boucle-for","title":"Boucle <code>for</code>","text":"<pre><code>for i in [1, 2, 3]:\n    print(i)\n</code></pre> <p>Avec <code>range</code> :</p> <pre><code>for i in range(5):\n    print(i)\n</code></pre>"},{"location":"4_intro_python/#break","title":"<code>break</code>","text":"<p>Interrompre la boucle :</p> <pre><code>for i in range(10):\n    if i == 3:\n        break\n    print(i)\n</code></pre>"},{"location":"4_intro_python/#continue","title":"<code>continue</code>","text":"<p>Passer \u00e0 l\u2019it\u00e9ration suivante :</p> <pre><code>for i in range(5):\n    if i == 2:\n        continue\n    print(i)\n</code></pre>"},{"location":"4_intro_python/#modules-et-fonctions","title":"Modules et fonctions","text":""},{"location":"4_intro_python/#modules","title":"Modules","text":"<p>Python propose une grande quantit\u00e9 de modules standards. Pour les utiliser, il suffit de les importer.</p> <p>Exemple avec le module <code>math</code> :</p> <pre><code>import math\nprint(math.sqrt(16))  # racine carr\u00e9e\n</code></pre> <p>On peut aussi importer une fonction sp\u00e9cifique :</p> <pre><code>from math import sqrt\nprint(sqrt(25))\n</code></pre> <p>Ou tout le module (fortement d\u00e9conseill\u00e9) :</p> <pre><code>from math import *\n</code></pre> <p>Il est \u00e9galement possible de renommer un module \u00e0 l\u2019import :</p> <pre><code>import math as m\nprint(m.sqrt(36))\n</code></pre>"},{"location":"4_intro_python/#creation-de-modules","title":"Cr\u00e9ation de modules","text":"<p>Un module Python est simplement un fichier <code>.py</code> contenant du code (fonctions, classes, etc.).</p> <p>Exemple dans <code>monmodule.py</code> :</p> <pre><code>def bonjour():\n    print(\"Bonjour depuis monmodule\")\n</code></pre> <p>Utilisation :</p> <pre><code>import monmodule\nmonmodule.bonjour()\n</code></pre> <p>Le module doit \u00eatre dans le m\u00eame dossier ou dans le PYTHONPATH.</p>"},{"location":"4_intro_python/#fonctions","title":"Fonctions","text":"<p>Les fonctions s\u2019\u00e9crivent avec le mot-cl\u00e9 <code>def</code> :</p> <pre><code>def salut():\n    print(\"Salut !\")\n</code></pre> <p>Appel :</p> <pre><code>salut()\n</code></pre> <p>Avec arguments :</p> <pre><code>def dire_bonjour(nom):\n    print(\"Bonjour\", nom)\n\ndire_bonjour(\"Alice\")\n</code></pre> <p>Avec valeur de retour :</p> <pre><code>def carre(x):\n    return x * x\n\nprint(carre(4))  # 16\n</code></pre>"},{"location":"4_intro_python/#parametres-par-defaut","title":"Param\u00e8tres par d\u00e9faut","text":"<pre><code>def saluer(nom=\"inconnu\"):\n    print(\"Salut\", nom)\n\nsaluer()\nsaluer(\"Bob\")\n</code></pre>"},{"location":"4_intro_python/#arguments-nommes","title":"Arguments nomm\u00e9s","text":"<pre><code>def personne(nom, age):\n    print(f\"{nom} a {age} ans\")\n\npersonne(age=30, nom=\"Alice\")\n</code></pre>"},{"location":"4_intro_python/#portee-des-variables","title":"Port\u00e9e des variables","text":"<ul> <li>Variables locales : d\u00e9finies dans une fonction</li> <li>Variables globales : d\u00e9finies hors fonction</li> </ul> <pre><code>x = 5  # globale\n\ndef afficher():\n    x = 10  # locale\n    print(x)\n\nafficher()  # 10\nprint(x)    # 5\n</code></pre> <p>Pour modifier une variable globale depuis une fonction :</p> <pre><code>x = 5\n\ndef modifier():\n    global x\n    x = 20\n\nmodifier()\nprint(x)  # 20\n</code></pre>"},{"location":"4_intro_python/#documentation-et-tests","title":"Documentation et tests","text":""},{"location":"4_intro_python/#la-documentation","title":"La documentation","text":"<p>La documentation est essentielle pour expliquer le r\u00f4le, le fonctionnement, et les param\u00e8tres d\u2019une fonction ou d\u2019un module.</p> <p>Python permet d\u2019associer une cha\u00eene de documentation \u00e0 une fonction, classe ou module gr\u00e2ce aux docstrings :</p> <pre><code>def addition(a, b):\n    \"\"\"Retourne la somme de a et b.\"\"\"\n    return a + b\n</code></pre> <p>On peut consulter cette documentation avec :</p> <pre><code>help(addition)\n</code></pre> <p>Ou encore :</p> <pre><code>print(addition.__doc__)\n</code></pre> <p>Les docstrings peuvent suivre la convention PEP 257 pour \u00eatre lisibles par des outils de g\u00e9n\u00e9ration de documentation.</p>"},{"location":"4_intro_python/#les-tests_1","title":"Les tests","text":""},{"location":"4_intro_python/#test-simple-avec-assert","title":"Test simple avec <code>assert</code>","text":"<p>Pour des tests l\u00e9gers, on peut aussi utiliser <code>assert</code> directement dans le code :</p> <pre><code>def somme(a, b):\n    return a + b\n\nassert somme(2, 3) == 5\nassert somme(-1, 1) == 0\n</code></pre> <p>Si l\u2019assertion \u00e9choue, Python l\u00e8ve une exception <code>AssertionError</code>.</p>"},{"location":"4_intro_python/#contexte-dexecution-des-tests","title":"Contexte d'ex\u00e9cution des tests","text":"<p>Une mani\u00e8re d'ex\u00e9cuter les tests est d'appeler les fonctions et de faire des assertions au niveau du module, dans un bloc <code>if __name__ == \"__main__\"</code>:</p> <p><pre><code># fichier somme.py\ndef somme(a, b):\n    return a + b\n\nif __name__ == \"__main__\": # sera ex\u00e9cut\u00e9 avec la commande `python somme.py`, ne sera pas ex\u00e9cut\u00e9 avec la commande `pyton main.py`\n    print(\"Testing somme.py...\")\n    assert somme(2, 3) == 5\n    assert somme(-1, 1) == 0\n</code></pre> <pre><code># fichier main.py\nimport somme as s\n\nprint(s.somme(3, 4))\n</code></pre></p>"},{"location":"5.c_exercices_tdg/","title":"Exercices de Th\u00e9orie des Graphes","text":"<p>TP de Th\u00e9orie des Graphes de Beno\u00eet Costes</p>"},{"location":"5_intro_tdg/","title":"Introduction \u00e0 la Th\u00e9orie des Graphes","text":""},{"location":"5_intro_tdg/#elements-de-theorie-des-graphes","title":"\u00c9l\u00e9ments de Th\u00e9orie des Graphes","text":"<p>Si vous voulez approfondir le cours, vous pouvez lire le cours de Th\u00e9orie des Graphes de Beno\u00eet Costes qui va beaucoup plus loin que cette page (qui en est un extrait).</p>"},{"location":"5_intro_tdg/#un-bref-historique-des-graphes","title":"Un bref historique des graphes","text":""},{"location":"5_intro_tdg/#premieres-definitions","title":"Premi\u00e8res d\u00e9finitions","text":""},{"location":"5_intro_tdg/#definition-intuitive-dun-graphe","title":"D\u00e9finition intuitive d'un graphe","text":""},{"location":"5_intro_tdg/#graphe-oriente","title":"Graphe orient\u00e9","text":""},{"location":"5_intro_tdg/#graphe-non-oriente","title":"Graphe non orient\u00e9","text":""},{"location":"5_intro_tdg/#ordre-dun-graphe","title":"Ordre d'un graphe","text":""},{"location":"5_intro_tdg/#relations-entre-les-elements-dun-graphe","title":"Relations entre les \u00e9l\u00e9ments d'un graphe","text":""},{"location":"5_intro_tdg/#relations-entre-les-sommets-dun-graphe","title":"Relations entre les sommets d'un graphe","text":""},{"location":"5_intro_tdg/#relations-entre-les-sommets-et-les-arcs-dun-graphe","title":"Relations entre les sommets et les arcs d'un graphe","text":""},{"location":"5_intro_tdg/#relations-entre-les-arcs-dun-graphe","title":"Relations entre les arcs d'un graphe","text":""},{"location":"5_intro_tdg/#multiplicite-et-degre","title":"Multiplicit\u00e9 et degr\u00e9","text":""},{"location":"5_intro_tdg/#graphe-partiel","title":"Graphe partiel","text":""},{"location":"5_intro_tdg/#graphe-et-sous-graphe-connexes","title":"Graphe et sous-graphe connexes","text":""},{"location":"5_intro_tdg/#modes-de-representation-dun-graphe","title":"Modes de repr\u00e9sentation d'un graphe","text":""},{"location":"5_intro_tdg/#matrice-dadjacence","title":"Matrice d'adjacence","text":""},{"location":"5_intro_tdg/#matrice-dincidence","title":"Matrice d'incidence","text":""},{"location":"5_intro_tdg/#matrice-sif","title":"Matrice SIF","text":""}]}